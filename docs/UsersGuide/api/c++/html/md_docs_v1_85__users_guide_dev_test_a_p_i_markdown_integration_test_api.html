<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>F´ Flight Software - C/C++ Documentation: Integration Test API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">F´ Flight Software - C/C++ Documentation
   &#160;<span id="projectnumber">NASA-v1.6.0</span>
   </div>
   <div id="projectbrief">A framework for building embedded system applications to NASA flight quality standards.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_docs_v1_85__users_guide_dev_test_a_p_i_markdown_integration_test_api.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Integration Test API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>gds_test_api.py:</p>
<p>This file contains basic asserts that can support integration tests on an FPrime deployment. This API uses the standard pipeline to get access to commands, events, telemetry and dictionaries.</p>
<ul>
<li><p class="startli"><b>author</b></p>
<p class="startli">koran</p>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md397"></a>
class fprime_gds.common.testing_fw.api.IntegrationTestAPI(pipeline, logpath=None, fsw_order=True)</h3>
<p>Bases: <code>object</code></p>
<p>A value used to begin searches after the current contents in a history and only search future items</p>
<h3><a class="anchor" id="autotoc_md398"></a>
&lt;strong&gt;init&lt;/strong&gt;(pipeline, logpath=None, fsw_order=True)</h3>
<p>Initializes API: constructs and registers test histories. Args:</p>
<blockquote class="doxtable">
<p>pipeline: a pipeline object providing access to basic GDS functionality logpath: an optional output destination for the api test log fsw_order: a flag to determine whether the API histories will maintain FSW time order. </p>
</blockquote>
<h3><a class="anchor" id="autotoc_md399"></a>
teardown()</h3>
<p>To be called once at the end of the API’s use. Closes the test log and clears histories.</p>
<h3><a class="anchor" id="autotoc_md400"></a>
start_test_case(case_name, case_id)</h3>
<p>To be called at the start of a test case. This function inserts a log message to denote a new test case is beginning, records the latest time stamp in case the user clears the aggregate histories, and then clears the API’s histories.</p>
<p>Args: </p><pre class="fragment">case_name: the name of the test case (str)
case_id: a short identifier to denote the test case (str or number)
</pre><h3><a class="anchor" id="autotoc_md401"></a>
log(msg, color=None)</h3>
<p>User-accessible function to log user messages to the test log. Args:</p>
<blockquote class="doxtable">
<p>msg: a user-provided message to add to the test log. (str) color: a string containing a color hex code “######” (str) </p>
</blockquote>
<h3><a class="anchor" id="autotoc_md402"></a>
get_latest_time()</h3>
<p>Finds the latest flight software time received by either history.</p>
<p>Returns: </p><pre class="fragment">a flight software timestamp (TimeType)
</pre><h3><a class="anchor" id="autotoc_md403"></a>
test_assert(value, msg='', expect=False)</h3>
<p>this assert gives the user the ability to add formatted assert messages to the test log and raise an assertion. Args:</p>
<blockquote class="doxtable">
<p>value: a boolean value that determines if the assert is successful. msg: a string describing what is checked by the assert. expect: when True, the call will behave as an expect, and will skip the assert (boolean) </p>
</blockquote>
<p>Return: </p><pre class="fragment">True if the assert was successful, False otherwise
</pre><h3><a class="anchor" id="autotoc_md404"></a>
predicate_assert(predicate, value, msg='', expect=False)</h3>
<p>API assert gives the user the ability to add formatted assert messages to the test log and raise an assertion. Args:</p>
<blockquote class="doxtable">
<p>value: the value to be evaluated by the predicate. (object) predicate: an instance of predicate that will decided if the test passes (predicate) msg: a string describing what is checked by the assert. (str) expect: when True, the call will behave as an expect, and will skip the assert (boolean) </p>
</blockquote>
<p>Return: </p><pre class="fragment">True if the assert was successful, False otherwise
</pre><h3><a class="anchor" id="autotoc_md405"></a>
clear_histories(time_stamp=None)</h3>
<p>Clears the IntegrationTestAPI’s histories. Because the command history is not correlated to a flight software timestamp, it will be cleared entirely. This function can be used to set up test cases so that the IntegrationTestAPI’s histories only contain objects received during that test. Note: this will not clear user-created sub-histories nor the aggregate histories (histories owned by the GDS)</p>
<p>Args: </p><pre class="fragment">time_stamp: If specified, histories are only cleared before the timestamp.
</pre><h3><a class="anchor" id="autotoc_md406"></a>
set_event_log_filter(event=None, args=None, severity=None, time_pred=None)</h3>
<p>Constructs an event predicate that is then used to filter which events are interlaced in the test logs. This method replaces the current filter. Calling this method with no arguments will effectively reset the filter.</p>
<p>Args: </p><pre class="fragment">event: an optional mnemonic (str), id (int), or predicate to specify the event type
args: an optional list of arguments (list of values, predicates, or None to ignore)
severity: an EventSeverity enum or a predicate to specify the event severity
time_pred: an optional predicate to specify the flight software timestamp
</pre><h3><a class="anchor" id="autotoc_md407"></a>
get_command_test_history()</h3>
<p>Accessor for IntegrationTestAPI’s command history Returns:</p>
<blockquote class="doxtable">
<p>a history of CmdData objects </p>
</blockquote>
<h3><a class="anchor" id="autotoc_md408"></a>
get_telemetry_test_history()</h3>
<p>Accessor for IntegrationTestAPI’s telemetry history Returns:</p>
<blockquote class="doxtable">
<p>a history of ChData objects </p>
</blockquote>
<h3><a class="anchor" id="autotoc_md409"></a>
get_event_test_history()</h3>
<p>Accessor for IntegrationTestAPI’s event history Returns:</p>
<blockquote class="doxtable">
<p>a history of EventData objects </p>
</blockquote>
<h3><a class="anchor" id="autotoc_md410"></a>
get_telemetry_subhistory(telemetry_filter=None, fsw_order=True)</h3>
<p>Returns a new instance of TestHistory that will be updated with new telemetry updates as they come in. Specifying a filter will only enqueue updates that satisfy the filter in this new sub-history. The returned history can be substituted into the await and assert methods of this API.</p>
<p>Args: </p><pre class="fragment">telemetry_filter: an optional predicate used to filter a subhistory.
fsw_order: a flag to determine whether this subhistory will maintain FSW time order.
</pre><p>Returns: </p><pre class="fragment">an instance of TestHistory
</pre><h3><a class="anchor" id="autotoc_md411"></a>
remove_telemetry_subhistory(subhist)</h3>
<p>De-registers the subhistory from the GDS. Once called, the given subhistory will stop receiving telemetry updates.</p>
<p>Args: </p><pre class="fragment">subhist: a TestHistory instance that is subscribed to event messages
</pre><p>Returns: </p><pre class="fragment">True if the subhistory was removed, False otherwise
</pre><h3><a class="anchor" id="autotoc_md412"></a>
get_event_subhistory(event_filter=None, fsw_order=True)</h3>
<p>Returns a new instance of TestHistory that will be updated with new events as they come in. Specifying a filter will only enqueue events that satisfy the filter in this new sub-history. The returned history can be substituted into the await and assert methods of this API.</p>
<p>Args: </p><pre class="fragment">event_filter: an optional predicate to filter a subhistory.
fsw_order: a flag to determine whether this subhistory will maintain FSW time order.
</pre><p>Returns: </p><pre class="fragment">an instance of TestHistory
</pre><h3><a class="anchor" id="autotoc_md413"></a>
remove_event_subhistory(subhist)</h3>
<p>De-registers the subhistory from the GDS. Once called, the given subhistory will stop receiving event messages.</p>
<p>Args: </p><pre class="fragment">subhist: a TestHistory instance that is subscribed to event messages
</pre><p>Returns: </p><pre class="fragment">True if the subhistory was removed, False otherwise
</pre><h3><a class="anchor" id="autotoc_md414"></a>
translate_command_name(command)</h3>
<p>This function will translate the given mnemonic into an ID as defined by the flight software dictionary. This call will raise an error if the command given is not in the dictionary.</p>
<p>Args: </p><pre class="fragment">command: Either the command id (int) or the command mnemonic (str)
</pre><p>Returns: </p><pre class="fragment">The comand ID (int)
</pre><h3><a class="anchor" id="autotoc_md415"></a>
send_command(command, args=[])</h3>
<p>Sends the specified command. Args:</p>
<blockquote class="doxtable">
<p>command: the mnemonic (str) or ID (int) of the command to send args: a list of command arguments. </p>
</blockquote>
<h3><a class="anchor" id="autotoc_md416"></a>
send_and_await_telemetry(command, args=[], channels=[], timeout=5)</h3>
<p>Sends the specified command and awaits the specified channel update or sequence of updates. See await_telemetry and await_telemetry_sequence for full details. Note: If awaiting a sequence avoid specifying timestamps.</p>
<p>Args: </p><pre class="fragment">command: the mnemonic (str) or ID (int) of the command to send
args: a list of command arguments.
channels: a single or a sequence of channel specs (event_predicates, mnemonics, or IDs)
start: an optional index or predicate to specify the earliest item to search
timeout: the number of seconds to wait before terminating the search (int)
</pre><p>Returns: </p><pre class="fragment">The channel update or updates found by the search
</pre><h3><a class="anchor" id="autotoc_md417"></a>
send_and_await_event(command, args=[], events=[], timeout=5)</h3>
<p>Sends the specified command and awaits the specified event message or sequence of messages. See await_event and await event sequence for full details. Note: If awaiting a sequence avoid specifying timestamps.</p>
<p>Args: </p><pre class="fragment">command: the mnemonic (str) or ID (int) of the command to send
args: a list of command arguments.
events: a single or a sequence of event specifiers (event_predicates, mnemonics, or IDs)
start: an optional index or predicate to specify the earliest item to search
timeout: the number of seconds to wait before terminating the search (int)
</pre><p>Returns: </p><pre class="fragment">The event or events found by the search
</pre><h3><a class="anchor" id="autotoc_md418"></a>
send_and_assert_telemetry(command, args=[], channels=[], timeout=5)</h3>
<p>Sends the specified command and asserts on the specified channel update or sequence of updates. See await_telemetry and await_telemetry_sequence for full details. Note: If awaiting a sequence avoid specifying timestamps.</p>
<p>Args: </p><pre class="fragment">command: the mnemonic (str) or ID (int) of the command to send
args: a list of command arguments.
channels: a single or a sequence of channel specs (event_predicates, mnemonics, or IDs)
start: an optional index or predicate to specify the earliest item to search
timeout: the number of seconds to wait before terminating the search (int)
</pre><p>Returns: </p><pre class="fragment">The channel update or updates found by the search
</pre><h3><a class="anchor" id="autotoc_md419"></a>
send_and_assert_event(command, args=[], events=[], timeout=5)</h3>
<p>Sends the specified command and asserts on the specified event message or sequence of messages. See assert_event and assert event sequence for full details.</p>
<p>Args: </p><pre class="fragment">command: the mnemonic (str) or ID (int) of the command to send
args: a list of command arguments.
events: a single or a sequence of event specifiers (event_predicates, mnemonics, or IDs)
start: an optional index or predicate to specify the earliest item to search
timeout: the number of seconds to wait before terminating the search (int)
</pre><p>Returns: </p><pre class="fragment">The event or events found by the search
</pre><h3><a class="anchor" id="autotoc_md420"></a>
translate_telemetry_name(channel)</h3>
<p>This function will translate the given mnemonic into an ID as defined by the flight software dictionary. This call will raise an error if the channel given is not in the dictionary.</p>
<p>Args: </p><pre class="fragment">channel: a channel mnemonic (str) or id (int)
</pre><p>Returns: </p><pre class="fragment">the channel ID (int)
</pre><h3><a class="anchor" id="autotoc_md421"></a>
get_telemetry_pred(channel=None, value=None, time_pred=None)</h3>
<p>This function will translate the channel ID, and construct a telemetry_predicate object. It is used as a helper by the IntegrationTestAPI, but could also be helpful to a user of the test API. If channel is already an instance of telemetry_predicate, it will be returned immediately. The provided implementation of telemetry_predicate evaluates true if and only if all specified constraints are satisfied. If a specific constraint isn’t specified, then it will not effect the outcome; this means all arguments are optional. If no constraints are specified, the predicate will always return true.</p>
<p>Args: </p><pre class="fragment">channel: an optional mnemonic (str), id (int), or predicate to specify the channel type
value: an optional value (object/number) or predicate to specify the value field
time_pred: an optional predicate to specify the flight software timestamp
</pre><p>Returns: </p><pre class="fragment">an instance of telemetry_predicate
</pre><h3><a class="anchor" id="autotoc_md422"></a>
await_telemetry(channel, value=None, time_pred=None, history=None, start='NOW', timeout=5)</h3>
<p>A search for a single telemetry update received. By default, the call will only await until a correct update is found. The user can specify that await also searches the current history by specifying a value for start. On timeout, the search will return None.</p>
<p>Args: </p><pre class="fragment">channel: a channel specifier (mnemonic, id, or predicate)
value: optional value (object/number) or predicate to specify the value field
time_pred: an optional predicate to specify the flight software timestamp
history: if given, a substitute history that the function will search and await
start: an optional index or predicate to specify the earliest item to search
timeout: the number of seconds to wait before terminating the search (int)
</pre><p>Returns: </p><pre class="fragment">the ChData object found during the search, otherwise, None
</pre><h3><a class="anchor" id="autotoc_md423"></a>
await_telemetry_sequence(channels, history=None, start='NOW', timeout=5)</h3>
<p>A search for a sequence of telemetry updates. By default, the call will only await until the sequence is completed. The user can specify that await also searches the history by specifying a value for start. On timeout, the search will return the list of found channel updates regardless of whether the sequence is complete. Note: It is reccomended (but not enforced) not to specify timestamps for this assert. Note: This function will always return a list of updates. The user should check if the sequence was completed.</p>
<p>Args: </p><pre class="fragment">channels: an ordered list of channel specifiers (mnemonic, id, or predicate)
history: if given, a substitute history that the function will search and await
start: an optional index or predicate to specify the earliest item to search
timeout: the number of seconds to wait before terminating the search (int)
</pre><p>Returns: </p><pre class="fragment">an ordered list of ChData objects that satisfies the sequence
</pre><h3><a class="anchor" id="autotoc_md424"></a>
await_telemetry_count(count, channels=None, history=None, start='NOW', timeout=5)</h3>
<p>A search on the number of telemetry updates received. By default, the call will only await until a correct count is achieved. The user can specify that await also searches the current history by specifying a value for start. On timeout, the search will return the list of found channel updates regardless of whether a correct count is achieved. Note: this search will always return a list of objects. The user should check if the search was completed.</p>
<p>Args: </p><pre class="fragment">count: either an exact amount (int) or a predicate to specify how many objects to find
channels: a channel specifier or list of channel specifiers (mnemonic, ID, or predicate)
history: if given, a substitute history that the function will search and await
start: an optional index or predicate to specify the earliest item to search
timeout: the number of seconds to wait before terminating the search (int)
</pre><p>Returns: </p><pre class="fragment">a list of the ChData objects that were counted
</pre><h3><a class="anchor" id="autotoc_md425"></a>
assert_telemetry(channel, value=None, time_pred=None, history=None, start=None, timeout=0)</h3>
<p>An assert on a single telemetry update received. If the history doesn’t have the correct update, the call will await until a correct update is received or the timeout, at which point it will assert failure.</p>
<p>Args: </p><pre class="fragment">channel: a channel specifier (mnemonic, id, or predicate)
value: optional value (object/number) or predicate to specify the value field
time_pred: an optional predicate to specify the flight software timestamp
history: if given, a substitute history that the function will search and await
start: an optional index or predicate to specify the earliest item to search
timeout: the number of seconds to wait before terminating the search (int)
</pre><p>Returns: </p><pre class="fragment">the ChData object found during the search
</pre><h3><a class="anchor" id="autotoc_md426"></a>
assert_telemetry_sequence(channels, history=None, start=None, timeout=0)</h3>
<p>A search for a sing sequence of telemetry updates messages. If the history doesn’t have the complete sequence, the call will await until the sequence is completed or the timeout, at which point it will return the list of found channel updates. Note: It is reccomended (but not enforced) not to specify timestamps for this assert. Note: This function will always return a list of updates the user should check if the sequence was completed.</p>
<p>Args: </p><pre class="fragment">channels: an ordered list of channel specifiers (mnemonic, id, or predicate)
history: if given, a substitute history that the function will search and await
start: an optional index or predicate to specify the earliest item to search
timeout: the number of seconds to wait before terminating the search (int)
</pre><p>Returns: </p><pre class="fragment">an ordered list of ChData objects that satisfies the sequence
</pre><h3><a class="anchor" id="autotoc_md427"></a>
assert_telemetry_count(count, channels=None, history=None, start=None, timeout=0)</h3>
<p>An assert on the number of channel updates received. If the history doesn’t have the correct update count, the call will await until a correct count is achieved or the timeout, at which point it will assert failure.</p>
<p>Args: </p><pre class="fragment">count: either an exact amount (int) or a predicate to specify how many objects to find
channels: a channel specifier or list of channel specifiers (mnemonic, ID, or predicate)
history: if given, a substitute history that the function will search and await
start: an optional index or predicate to specify the earliest item to search
timeout: the number of seconds to wait before terminating the search (int)
</pre><p>Returns: </p><pre class="fragment">a list of the ChData objects that were counted
</pre><h3><a class="anchor" id="autotoc_md428"></a>
translate_event_name(event)</h3>
<p>This function will translate the given mnemonic into an ID as defined by the flight software dictionary. This call will raise an error if the event given is not in the dictionary.</p>
<p>Args: </p><pre class="fragment">event: an event mnemonic (str) or ID (int)
</pre><p>Returns: </p><pre class="fragment">the event ID (int)
</pre><h3><a class="anchor" id="autotoc_md429"></a>
get_event_pred(event=None, args=None, severity=None, time_pred=None)</h3>
<p>This function will translate the event ID, and construct an event_predicate object. It is used as a helper by the IntegrationTestAPI, but could also be helpful to a user of the test API. If event is already an instance of event_predicate, it will be returned immediately. The provided implementation of event_predicate evaluates true if and only if all specified constraints are satisfied. If a specific constraint isn’t specified, then it will not effect the outcome; this means all arguments are optional. If no constraints are specified, the predicate will always return true.</p>
<p>Args: </p><pre class="fragment">event: mnemonic (str), id (int), or predicate to specify the event type
args: list of arguments (list of values, predicates, or None to ignore)
severity: an EventSeverity enum or a predicate to specify the event severity
time_pred: predicate to specify the flight software timestamp
</pre><p>Returns: </p><pre class="fragment">an instance of event_predicate
</pre><h3><a class="anchor" id="autotoc_md430"></a>
await_event(event, args=None, severity=None, time_pred=None, history=None, start='NOW', timeout=5)</h3>
<p>A search for a single event message received. By default, the call will only await until a correct message is found. The user can specify that await also searches the current history by specifying a value for start. On timeout, the search will return None.</p>
<p>Args: </p><pre class="fragment">event: an event specifier (mnemonic, id, or predicate)
args: a list of expected arguments (list of values, predicates, or None for don’t care)
severity: an EventSeverity enum or a predicate to specify the event severity
time_pred: an optional predicate to specify the flight software timestamp
history: if given, a substitute history that the function will search and await
start: an optional index or predicate to specify the earliest item to search
timeout: the number of seconds to wait before terminating the search (int)
</pre><p>Returns: </p><pre class="fragment">the EventData object found during the search, otherwise, None
</pre><h3><a class="anchor" id="autotoc_md431"></a>
await_event_sequence(events, history=None, start='NOW', timeout=5)</h3>
<p>A search for a sequence of event messages. By default, the call will only await until the sequence is completed. The user can specify that await also searches the history by specifying a value for start. On timeout, the search will return the list of found event messages regardless of whether the sequence is complete. Note: It is reccomended (but not enforced) not to specify timestamps for this assert. Note: This function will always return a list of events the user should check if the sequence was completed.</p>
<p>Args: </p><pre class="fragment">events: an ordered list of event specifiers (mnemonic, id, or predicate)
history: if given, a substitute history that the function will search and await
start: an optional index or predicate to specify the earliest item to search
timeout: the number of seconds to wait before terminating the search (int)
</pre><p>Returns: </p><pre class="fragment">an ordered list of EventData objects that satisfies the sequence
</pre><h3><a class="anchor" id="autotoc_md432"></a>
await_event_count(count, events=None, history=None, start='NOW', timeout=5)</h3>
<p>A search on the number of events received. By default, the call will only await until a correct count is achieved. The user can specify that this await also searches the current history by specifying a value for start. On timeout, the search will return the list of found event messages regardless of whether a correct count is achieved. Note: this search will always return a list of objects. The user should check if the search was completed.</p>
<p>Args: </p><pre class="fragment">count: either an exact amount (int) or a predicate to specify how many objects to find
events: an event specifier or list of event specifiers (mnemonic, ID, or predicate)
history: if given, a substitute history that the function will search and await
start: an optional index or predicate to specify the earliest item to search
timeout: the number of seconds to wait before terminating the search (int)
</pre><p>Returns: </p><pre class="fragment">a list of the EventData objects that were counted
</pre><h3><a class="anchor" id="autotoc_md433"></a>
assert_event(event, args=None, severity=None, time_pred=None, history=None, start=None, timeout=0)</h3>
<p>An assert on a single event message received. If the history doesn’t have the correct message, the call will await until a correct message is received or the timeout, at which point it will assert failure.</p>
<p>Args: </p><pre class="fragment">event: an event specifier (mnemonic, id, or predicate)
args: a list of expected arguments (list of values, predicates, or None for don’t care)
severity: an EventSeverity enum or a predicate to specify the event severity
time_pred: an optional predicate to specify the flight software timestamp
history: if given, a substitute history that the function will search and await
start: an optional index or predicate to specify the earliest item to search
timeout: the number of seconds to wait before terminating the search (int)
</pre><p>Returns: </p><pre class="fragment">the EventData object found during the search
</pre><h3><a class="anchor" id="autotoc_md434"></a>
assert_event_sequence(events, history=None, start=None, timeout=0)</h3>
<p>An assert that a sequence of event messages is received. If the history doesn’t have the complete sequence, the call will await until the sequence is completed or the timeout, at which point it will assert failure. Note: It is reccomended (but not enforced) not to specify timestamps for this assert.</p>
<p>Args: </p><pre class="fragment">events: an ordered list of event specifiers (mnemonic, id, or predicate)
history: if given, a substitute history that the function will search and await
start: an optional index or predicate to specify the earliest item to search
timeout: the number of seconds to wait before terminating the search (int)
</pre><p>Returns: </p><pre class="fragment">an ordered list of EventData objects that satisfied the sequence
</pre><h3><a class="anchor" id="autotoc_md435"></a>
assert_event_count(count, events=None, history=None, start=None, timeout=0)</h3>
<p>An assert on the number of events received. If the history doesn’t have the correct event count, the call will await until a correct count is achieved or the timeout, at which point it will assert failure.</p>
<p>Args: </p><pre class="fragment">count: either an exact amount (int) or a predicate to specify how many objects to find
events: optional event specifier or list of specifiers (mnemonic, id, or predicate)
history: if given, a substitute history that the function will search and await
start: an optional index or predicate to specify the earliest item to search
timeout: the number of seconds to wait before terminating the search (int)
</pre><p>Returns: </p><pre class="fragment">a list of the EventData objects that were counted
</pre><h3><a class="anchor" id="autotoc_md436"></a>
exception TimeoutException()</h3>
<p>Bases: <code>Exception</code></p>
<p>This exception is used by the history searches to signal the end of the timeout.</p>
<h3><a class="anchor" id="autotoc_md437"></a>
&lt;strong&gt;weakref&lt;/strong&gt;()</h3>
<p>list of weak references to the object (if defined)</p>
<h3><a class="anchor" id="autotoc_md438"></a>
find_history_item(search_pred, history, start=None, timeout=0)</h3>
<p>This function can both search and await for an element in a history. The function will return the first valid object it finds. The search will return when an object is found, or the timeout is reached.</p>
<p>Args: </p><pre class="fragment">search_pred: a predicate to specify a history item.
history: the history that the function will search and await
start: an index or predicate to specify the earliest item from the history to search
timeout: the number of seconds to wait before terminating the search (int)
</pre><p>Returns: </p><pre class="fragment">the data object found during the search, otherwise, None
</pre><h3><a class="anchor" id="autotoc_md439"></a>
find_history_sequence(seq_preds, history, start=None, timeout=0)</h3>
<p>This function can both search and await for a sequence of elements in a history. The function will return a list of the history objects to satisfy the sequence search. The search will return when an order of data objects is found that satisfies the entire sequence, or the timeout occurs. Note: this search will always return a list of objects. The user should check if the search was completed.</p>
<p>Args: </p><pre class="fragment">seq_preds: an ordered list of predicate objects to specify a sequence
history: the history that the function will search and await
start: an index or predicate to specify the earliest item from the history to search
timeout: the number of seconds to wait before terminating the search (int)
</pre><p>Returns: </p><pre class="fragment">a list of data objects that satisfied the sequence
</pre><h3><a class="anchor" id="autotoc_md440"></a>
&lt;strong&gt;weakref&lt;/strong&gt;()</h3>
<p>list of weak references to the object (if defined)</p>
<h3><a class="anchor" id="autotoc_md441"></a>
find_history_count(count, history, search_pred=None, start=None, timeout=0)</h3>
<p>This function first counts all valid items in the current history, then can await until a valid number of elements is received by the history. The function will return a list of the history objects counted by the search. The search will return when a correct count of data objects is found, or the timeout occurs. Note: this search will always return a list of objects. The user should check if the search was completed.</p>
<p>Args: </p><pre class="fragment">count: either an exact amount (int) or a predicate to specify how many objects to find
history: the history that the function will search and await
search_pred: a predicate to specify which items to count. If left blank, all will count
start: an index or predicate to specify the earliest item from the history to search
timeout: the number of seconds to wait before terminating the search (int)
</pre><p>Returns: </p><pre class="fragment">a list of data objects that were counted during the search
</pre><h3><a class="anchor" id="autotoc_md442"></a>
data_callback(data_object)</h3>
<p>Data callback used by the api to log events and detect when they are received out of order. Args:</p>
<blockquote class="doxtable">
<p>data_object: object to store </p>
</blockquote>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Quick Links  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">../user_guide.md "Integration Test API User Guide"  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">../../../../../Gds/README.md "GDS Overview"  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a class="el" href="v2_80_80_2_users_guide_2dev_2test_a_p_i_2markdown_2integration__test__api_8md.html">Integration Test API</a>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><a class="el" href="v2_80_80_2_users_guide_2dev_2test_a_p_i_2markdown_2histories_8md.html">Histories</a>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a class="el" href="v2_80_80_2_users_guide_2dev_2test_a_p_i_2markdown_2predicates_8md.html">Predicates</a>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><a class="el" href="v2_80_80_2_users_guide_2dev_2test_a_p_i_2markdown_2test__logger_8md.html">Test Logger</a>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a class="el" href="v2_80_80_2_users_guide_2dev_2test_a_p_i_2markdown_2standard__pipeline_8md.html">Standard Pipeline</a>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><a class="el" href="v2_80_80_2_users_guide_2dev_2test_a_p_i_2markdown_2time__type_8md.html">TimeType Serializable</a>  </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
