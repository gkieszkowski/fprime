<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>F´ Flight Software - C/C++ Documentation: F´ On Baremetal and Multi-Core Systems</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">F´ Flight Software - C/C++ Documentation
   &#160;<span id="projectnumber">NASA-v1.6.0</span>
   </div>
   <div id="projectbrief">A framework for building embedded system applications to NASA flight quality standards.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_docs_v2_80_80__users_guide_dev_baremetal-multicore.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">F´ On Baremetal and Multi-Core Systems </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>F´ supports use on baremetal, multi-core, and even multi-device systems. This guide seeks to walk the user though some of the caveats and delicacies of such systems. It includes</p>
<ul>
<li><a href="#baremetal-systems">Baremetal Systems</a><ul>
<li><a href="#the-joy-of-passive-components">The Joy of Passive Components</a></li>
<li><a href="#choosing-an-execution-context">Choosing an Execution Context</a></li>
</ul>
</li>
<li><a href="#multi-core-and-multi-device-systems">Multi-Core and Multi-Device Systems</a></li>
<li><a href="#thread-virtualization">Thread Virtualization</a><ul>
<li><a href="#defining-custom-tasks">Defining Custom Tasks</a></li>
<li><a href="#how-it-works">How It Works</a></li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md864"></a>
Baremetal Systems</h1>
<p>A baremetal system is a system that does not run an Operating System to support the F´ software. Thus, the F´ software must provide for basic services such as filesystems, thread schedulers, etc, to run. Since F´ was originally run on systems that provide these services, a number of precautions must be taken when designing F´systems for baremetal platforms.</p>
<h2><a class="anchor" id="autotoc_md865"></a>
The Joy of Passive Components</h2>
<p>First and foremost, baremetal F´ systems should avoid using <b>Active Components</b> at all costs because these components require quasi-asynchronous execution contexts in which to run. i.e. they need thread such that they can execute in "parallel" with each other. <b>Note:</b> if you <b>must</b> use <b>Active Components</b> you should thoroughly review the <a href="#thread-virtualization">thread virtualization</a> section of this document an associated technology.</p>
<p>If your system can be entirely defined by <b>Passive Components</b> then implicitly every port <b>invocation</b> would be synchronous and the the execution context would be entirely delegated to every component. A discussion of the source of that delegated execution context comes next.</p>
<h2><a class="anchor" id="autotoc_md866"></a>
Choosing an Execution Context</h2>
<p>Since the OS is not around to execute F´, the implementer of the F´ project must choose an execution context for F´ to run on. That is, ensuring that some call invokes all of the <b>Components</b> that compose the F´ system. Otherwise some components will not run. Typically, this is handled by composing an F´ baremetal system into components that are all driven by ../best/rate-group.md "rate groups". Designing the system this way ensures that all execution is derived from one source: the rate group driver and thus reducing the problem to supplying an execution context to the rate group driver at a set rate. All calls needed will execute a during a sweep through the rate groups a their derived rates.</p>
<p><b>Note:</b> other options exist (see <a href="#thread-virtualization">Thread Virtualization</a> below).</p>
<p>Although a full discussion of supplying execution context to the rate group driver is outside the scope of this documentation, this author wanted to provide a few tip. First, F´ execution should be primarily derived from the main program loop. i.e. embedded software typically looks like the following and the loop-forever <code>execute();</code> action should trigger the rate group driver at a set interval.</p>
<div class="fragment"><div class="line"><span class="comment">// Run once setup</span></div>
<div class="line">setup();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Do this forever</span></div>
<div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">   execute();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now all that is required is to determine when this interval has elapsed. This can be done spinning on a hardware clock signal, calculating elapsed time by reading of clock registers, using timing library functions, the <code>sleep()</code> call, or by an timer driven interrupt service routine (ISR). <b>Note:</b> ISRs are complex items and should be studied in detail before going this route. Notably, the ISR should not execute the rate group directly, but rather should set a flag or queue a start message and allow the <code>while (true) {}</code> spin in the main loop to detect this signal and start the rate groups.</p>
<h1><a class="anchor" id="autotoc_md867"></a>
Multi-Core and Multi-Device Systems</h1>
<p>We have yet to see any issues running F´ on multi-core systems. Some users have been successful scheduling high-priority components to designated cores. In general these systems behave just fine. <b>Note:</b> some portions of F´ use <code>U32</code> types so synchronize between threads. In many systems this is a safe atomic operation, however; this is not guaranteed on all systems. A project should use care to ensure that their system will behave as expected. These usages are under review and will be corrected over time.</p>
<p>When running F´ on multi-platform systems, users typically define a deployment for each platform in the system. These deployments are then linked over the platform's inter-communication architecture. Should users want F´ execution across these deployments to look like a single F´ deployment, users are advised to adapt the ../best/hub-pattern.md "hub pattern" to invoke F´ port calls across multiple devices.</p>
<h1><a class="anchor" id="autotoc_md868"></a>
Thread Virtualization</h1>
<p><b>Note:</b> this is an experimental technology with respect to F´. Care to understand its implementation should be taken before using in a production/flight context.</p>
<p>Some systems, even baremetal systems, require the use of <b>Active Components</b>. Many of the <code><a class="el" href="namespace_svc.html">Svc</a></code> components are by design active components. It is impractical to assume that all projects can, at the moment of conception, discard all use of framework provided <b>Active Components</b>. Thus F´ was augmented with the ability to virtualize threading, such that projects could use these components during development as they migrate to a fully passive-component system.</p>
<p>To activate this feature see: ../user/configuration.md "Configuring F´". Continue reading for all the fancy details of how this system is designed. TODO: put a link to the thread scheduler API documentation.</p>
<h2><a class="anchor" id="autotoc_md869"></a>
Defining Custom Tasks</h2>
<p>When using the thread virtualization technology, care should be taken with custom tasks/threads. This design, as described below, is dependent on threads that "run once" and externalize the looping part of the thread. Therefore, custom tasks must wrap functions that obey the following implementation requirements:</p>
<ol type="1">
<li>The function shall not loop</li>
<li>The function shall never block execution</li>
<li>The function shall perform "one slice" of the thread then return</li>
</ol>
<p>Failure to comply with these requirements will cause the thread virtualization technology to fail, and the F´ application to lock-up or otherwise behave erratically.</p>
<h2><a class="anchor" id="autotoc_md870"></a>
How It Works</h2>
<p>At the core of <b>Active Components</b> is a thread, which typically requires an <a class="el" href="namespace_os.html">Os</a> to provide a scheduler for it to run, and through this scheduler it gets designated an execution context to run in. Thus threads can execute as if they fully own their execution context and the <a class="el" href="namespace_os.html">Os</a> masks this behind the scenes. The purpose of the thread virtualization when enabled for an F´ project is to unroll these threads such that they can share a single execution context and the parallel behavior of the threads is "virtualized". The technique is known as protothreading. We'll explore this concept with relation to F´ below.</p>
<p>Each F´ thread supporting an Active component can be roughly modeled by the code below. The thread loops until the system shuts down. For each iteration through the loop it blocks (pauses execution) until a message arrives. It then dispatches the message and returns to a blocked state waiting for the next message.</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">Component1 :: run_thread() {</div>
<div class="line">    while (!shutdown) {</div>
<div class="line">        msg = block_get_message();</div>
<div class="line">        dispatch(msg);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Here <code>block_get_messages();</code> retrieves messages, blocking until one arrives. This loop could have easily been implemented using a less-efficient model by iterating continuously through the loop and checking if a message has arrived and dispatching if and only if a message is available. As can be seen below, the wait-by-blocking has been replaced by the busy wait of constantly iterating through the loop.</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">void Component1 :: run_once() {</div>
<div class="line">    if (message_count() &gt; 0) {</div>
<div class="line">        msg = nonblock_get_message();</div>
<div class="line">        dispatch(msg);</div>
<div class="line">    }</div>
<div class="line">    return;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">Component1 :: run_thread() {</div>
<div class="line">    while (!shutdown) {</div>
<div class="line">        comp1.run_once();</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Here, we extracted the iteration into a <code>run_once</code> function such for clarity. The blocking wait in the first function is replaced with a spin on an if-condition until a message is available, then the dispatch happens.</p>
<p>It should be only a slight extrapolation that one could move all the component <code>run_once</code> functions into a single loop and call each in succession. As long as these calls returns in a reasonable amount of time, and none of these calls block internally, then crude parallelism is achieved.</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">while (!shutdown) {</div>
<div class="line">    comp1.run_once();</div>
<div class="line">    comp2.run_once();</div>
<div class="line">    comp3.run_once();</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>Here, as seen above, <code>run_once</code> does not block and so each component gets a slice of execution time before yielding to the next. Parallelism has been virtualized and the processor is shareable without writing a full-blown thread scheduler nor requiring processor instruction set support to switch threading contexts.</p>
<p>Inside F´ a parallel implementation of the active component task was implemented such that it returns rather than blocks on receiving messages. When <code>BAREMERAL_SCHEDULER</code> is enabled in the F´ configuration, this alternate implementation is used. Under <code>Os/Baremetal</code> an implementation of a sequential scheduler is implemented. This scheduler snoops on task registration and will call all thread executions in a loop driven from the main program loop similar to below.</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">setup(); // Setup F´</div>
<div class="line">while (true) {</div>
<div class="line">    scheduler.run_once();</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
