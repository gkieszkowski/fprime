<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>F´ Flight Software - C/C++ Documentation: Unit Testing in F´</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">F´ Flight Software - C/C++ Documentation
   &#160;<span id="projectnumber">NASA-v1.6.0</span>
   </div>
   <div id="projectbrief">A framework for building embedded system applications to NASA flight quality standards.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_docs_v1_85__users_guide_user_unit-testing.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Unit Testing in F´ </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Testing is an important part of flight software (FSW) development. Testing is divided into two phases: i) unit testing, and ii) integration testing. Unit testing tests the individual units, such as F′ components, while integration testing tests the integrated system. Test framework classes include the auto-generated <em>TesterBase</em>, the auto-generated <em>GTestBase</em>, and the developer-written <em>Tester</em>. The testing phases and test framework classes are discussed in further detail below.</p>
<h1><a class="anchor" id="autotoc_md695"></a>
Unit Testing</h1>
<p>Thorough unit testing is critical. It provides unit-level regression tests, and makes integration easier since localized errors are caught early and system-level issues only appear during integration.</p>
<p>F′ provides the support for unit testing at the component level. The overall framework for unit testing is shown in Figure 1.</p>
<p><img src="../media/test1.png" alt="Tesst" class="inline"/></p>
<p><b>Figure 1.</b> Unit testing framework overview.</p>
<p>The goal of unit testing is to cover all component-level requirements, and achieve close to 100% code coverage and a reasonable amount of system state and path coverage. These requirements should drive the tests. A record of how the tests cover the requirements should be maintained. Mapping the tests to requirements can be recorded on a spreadsheet, or in the actual test using comments or in the console output mechanism.</p>
<p>To start, generate the test classes and add public test methods to the tester. The <em>TesterBase</em> and the <em>GTestBase</em> are auto-generated, while the <em>Tester</em> is developer-written from a generated template.</p>
<p><em><b>TesterBase</b></em> is the base class for testing a component and provides a harness for unit tests. The <em>TesterBase</em> interface is the mirror image of the component (<em>C</em>) under test. For each output port in <em>C</em> there is an input port called a “from port,” and for each input port in <em>C</em> there is an output port called a “to port.” For each “from port” there is a history (<em>H</em>) of data received through a virtual input handler that stores its argument into <em>H</em>. The <em>TesterBase</em> provides utility methods for writing tests to the component. These include sending commands, sending invocations on to ports, and getting and setting parameters and time.</p>
<p><em><b>GTestBase</b></em> is derived from the <em>TesterBase</em> and includes headers for the Google Test framework with F′ specific macros. It supports test assertions, such as <em>ASSERT_EQ(3, x)</em> to check that two values are equal when writing tests. The F′ specific macros check the telemetry received from the ports, the events received from the ports, and the data received (user-defined) from the ports. The <em>GTestBase</em> is factored into a separate class so its use is optional on systems that do not support it.</p>
<p><em><b>Tester</b></em> is derived from the <em>GTestBase</em> and contains the component under test as a member. The autocoder provides a template where the user then adds tests as a public method, and also write tests in a derived class of the <em>Tester</em>.</p>
<p>Once the test class is generated, the user can begin to send commands, check events and telemetry, check user-defined output ports, set parameters and the time, build and run the unit tests from the <em>component directory</em>, and finally analyze the code coverage from the <em>component directory</em> after building and running the test. However, be sure to review the analysis from the <em>test/ut directory</em>.</p>
<p>A standard approach to writing unit tests is to write a complete test that covers the requirement. If there is overlap, refactoring into functions is the preferred approach to avoid code duplication. A more disciplined approach would be to write functions that test individual behaviors. When writing test code treat unit testing as a programming problem by applying similar style guidelines as the flight code. This approach avoids less code duplication and provides more readable, maintainable, and modifiable tests.</p>
<p>When writing unit tests for a component be sure to test against the interface, such as the send commands and the send data on the output ports. Read the internal component state to verify it is good, and only modify the state through the interface; do not update the state of the component. This approach leads to a more structured test. If there is a requirement to test a function in a component implementation that has a complex algorithm, then write a test against the function interface.</p>
<p>When unit testing a component, model the external behavior to receive commands and send responses by writing a test harness. This approach supports modularity testing that can be used for many tests.</p>
<p>To check event and telemetry histories the user first sends a command, and then checks events and telemetry by writing the following code.</p>
<p><b>Sending Commands:</b></p>
<div class="fragment"><div class="line">// Send command</div>
<div class="line">this-&gt;sendCOMMAND_NAME(</div>
<div class="line">    cmdSeq, // Command sequence number</div>
<div class="line">    arg1, // Argument 1</div>
<div class="line">    arg2 // Argument 2</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">this-&gt;component.doDispatch();</div>
<div class="line">// Assert command response</div>
<div class="line">ASSERT_CMD_RESPONSE\_SIZE(1);</div>
<div class="line">ASSERT_CMD_RESPONSE(</div>
<div class="line">    0, // Index in the history</div>
<div class="line">    Component::OPCODE\_COMMAND\_NAME, // Expected command opcode</div>
<div class="line">    cmdSeq, // Expected command sequence number</div>
<div class="line">    Fw::COMMAND_OK // Expected command response</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Checking Events:</b></p>
<div class="fragment"><div class="line">// Send command and check response</div>
<div class="line">…</div>
<div class="line"> </div>
<div class="line">// Assert total number of events in history</div>
<div class="line">ASSERT_EVENTS_SIZE(1);</div>
<div class="line"> </div>
<div class="line">// Assert number of a particular event</div>
<div class="line">ASSERT_EVENTS_EventName_SIZE(1);</div>
<div class="line"> </div>
<div class="line">// Assert arguments for a particular event</div>
<div class="line">ASSERT_EVENTS_EventName(</div>
<div class="line">    0, // Index in history</div>
<div class="line">    arg1, // Expected value of argument 1</div>
<div class="line">    arg2 // Expected value of argument 2</div>
<div class="line">);</div>
</div><!-- fragment --><p><b>Checking Telemetry:</b> </p><div class="fragment"><div class="line">// Send command and check response</div>
<div class="line">…</div>
<div class="line"> </div>
<div class="line">// Assert total number of telemetry entries in history</div>
<div class="line">ASSERT_TLM_SIZE(1);</div>
<div class="line"> </div>
<div class="line">// Assert number of entries on a particular channel</div>
<div class="line">ASSERT_TLM_ChannelName_SIZE(1);</div>
<div class="line"> </div>
<div class="line">// Assert value for a particular entry</div>
<div class="line">ASSERT_TLM_ChannelName(</div>
<div class="line">    0, // Index in history</div>
<div class="line">    value // Expected value</div>
<div class="line">);</div>
</div><!-- fragment --><p>To check the user-defined output ports write the following code. </p><div class="fragment"><div class="line">// Send command and check response</div>
<div class="line">…</div>
<div class="line"> </div>
<div class="line">// Assert total number of entries on from ports</div>
<div class="line">ASSERT_FROM_PORT_HISTORY_SIZE(1);</div>
<div class="line"> </div>
<div class="line">// Assert number of entries on a particular from port</div>
<div class="line">ASSERT_from_PortName_SIZE(1);</div>
<div class="line"> </div>
<div class="line">// Assert value for a particular entry</div>
<div class="line">ASSERT_from_PortName(</div>
<div class="line">    0, // Index in history</div>
<div class="line">    arg1, // Expected value of argument 1</div>
<div class="line">    arg2 // Expected value of argument 2</div>
<div class="line">);</div>
</div><!-- fragment --><p>To set the parameters in a test of component <em>C</em>, write the following code. This call stores the argument in member variables of <em>TesterBase</em>, so when <em>C</em> invokes the <em>ParamGet</em> port it receives the argument.</p>
<div class="fragment"><div class="line">this-&gt;paramSet_ParamName(</div>
<div class="line">    value, // Parameter value</div>
<div class="line">    Fw::PARAM_VALID // Parameter status</div>
<div class="line">);</div>
</div><!-- fragment --><p>Next, to set the time in a text of component <em>C</em>, write the following code. <em>Time</em> is an <em><a class="el" href="class_fw_1_1_time.html">Fw::Time</a></em> object, so when <em>C</em> invokes the <em>TimeGet</em> port it receives the value time.</p>
<p><code>this-&gt;setTime(time)</code></p>
<p>The F′ Prime build system provides targets for building and running component unit tests.</p>
<p>To build unit tests, go to the component directory (not the <em>test/ut</em> directory) and run <em>make ut</em> to build with code coverage enabled, or run <em>make ut_nocov</em> to build with code coverage disabled.</p>
<p>To run unit tests, go to the component directory (not the <em>test/ut</em> directory) and run <em>make run_ut</em> to run with coverage enabled, or <em>make run_ut_nocov</em> to run with coverage disabled.</p>
<p>Components that call into libraries have two ways to write tests: i) link against the library in the test, or ii) link against a mock or stub library. Selecting from either of these two options depend on the circumstances. If selecting the link against the library in the test, avoid writing the mock or stub library. This approach proves that the component code works with the actual library. If selecting the link against a mock or stub library, it will make it easier to induce the behaviors for testing, such as injecting faults. This approach may be the only option on some platforms.</p>
<p>Checking code coverage checks which lines were run at least once during a test. There are standard tools, such as <em>gcov</em>, that can perform this analysis by compiling and running the tests, and then produce a report. Generally, code coverage checks close to 80% of lines. The remaining lines are usually off-nominal behaviors that may require additional effort to check by reverse reasoning from the desired behavior to synthesize the inputs, or by injecting faults into the library behaviors. However, 100% code coverage is not a complete solution to checking which system states were tested, or which paths through the code were tested, as this is not possible.</p>
<p>To generate the analysis, go to the component directory (not the <em>test/ut</em> directory). After building and running the tests as outlined above, run <em>make cov</em>. The review the analysis, go to the <em>test/ut</em> directory (not the component director) and review the summary output *_gcov.txt* files. Next, go to the component directory to review the coverage annotation *.hpp.gcov* and *.cpp.gcov* source files. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
