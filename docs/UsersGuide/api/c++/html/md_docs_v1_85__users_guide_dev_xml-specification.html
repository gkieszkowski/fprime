<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>F´ Flight Software - C/C++ Documentation: F´ XML Specifications</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">F´ Flight Software - C/C++ Documentation
   &#160;<span id="projectnumber">NASA-v1.6.0</span>
   </div>
   <div id="projectbrief">A framework for building embedded system applications to NASA flight quality standards.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_docs_v1_85__users_guide_dev_xml-specification.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">F´ XML Specifications </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>Note:</b> for a hands-on walk through of build topologies, please see: ../../Tutorials/README.md "Tutorials". This is an advanced specification and the hands-on tutorial is likely better for new users.</p>
<p>Serializable types, arrays, ports, and components are defined in XML files. Those files are parsed by the code generator, and files containing C++ class declarations are created. This section will describe the syntax of the XML files.</p>
<p>This guide describes the XML format for:</p>
<p>-<a href="#serializable">Serializable</a> -<a href="#port">Ports</a> -<a href="#components">Components</a> -<a href="#topologies">Topologies</a></p>
<h1><a class="anchor" id="autotoc_md558"></a>
Serializable</h1>
<p>Serializables are the types that are passed between components in the architecture and are used for ground data services such as commands, telemetry, events, and parameters (see the component description in Section 6.6.3 for what these are). A serializable type is a complex or basic type that can be converted to a data buffer that contains the values of an instance of the type. This data buffer can be passed around the system (and to ground software) in a generic way and reconstituted into the original type as needed. Basic C/C++ types like int and float are supported automatically in the architecture, but the user is also allowed to define arbitrary complex types that can be serialized. This is done in one of two ways, either by hand-coding a class or allowing the code generator to generate the class. These types can then be used in XML specifications of ports and components.</p>
<h2><a class="anchor" id="autotoc_md559"></a>
XML-Specified Serializable</h2>
<p>In most cases, a complex type is representable as a collection of simple types. This is analogous to a C struct with data members. The code for serializing and deserializing a struct is straightforward, so a code generator is provided that will create the classes for a serializable struct. The user specifies the members in XML, and the C++ class is generated. The types of the members can be basic types or other serializables, either XML or hand-coded. In order for the build system to detect that a file contains the XML for a serializable type, the file must follow the naming convention &lt;SomeName&gt;SerializableAi.xml. An example of this can be found in Autocoders/templates/ExampleSerializableAi.xml. Table 16 describes the XML tags and attributes to use for the serializable.</p>
<p><b>Table 16.</b> Serializable XML specification.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Tag </th><th class="markdownTableHeadNone">Attribute </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">serializable </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">The outermost tag that indicates a serializable is being defined.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">serializable </td><td class="markdownTableBodyNone">namespace </td><td class="markdownTableBodyNone">The C++ namespace for the serializable class (optional).  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">serializable </td><td class="markdownTableBodyNone">name </td><td class="markdownTableBodyNone">The class name for the serializable.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">serializable </td><td class="markdownTableBodyNone">typeid </td><td class="markdownTableBodyNone">An integer uniquely identifying the type. Optional; generated from hash otherwise. Should be unique across the application.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">comment </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Used for a comment describing the type. Is placed as a Doxygen-compatible tag in the class declaration.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">members </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Starts the region of the declaration where type members are specified.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">member </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Defines a member of the type.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">member </td><td class="markdownTableBodyNone">type </td><td class="markdownTableBodyNone">The type of the member. Should be a built-in type, ENUM, string, an XML-specified type, or a user-written serializable type.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">member </td><td class="markdownTableBodyNone">name </td><td class="markdownTableBodyNone">Defines the member name.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">member </td><td class="markdownTableBodyNone">size </td><td class="markdownTableBodyNone">Specifies that the member is an array of the type with the specified size.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">member </td><td class="markdownTableBodyNone">format </td><td class="markdownTableBodyNone">Specifies a format specifier when displaying the member.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">enum </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Specifies an enumeration when the member type=ENUM.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">enum </td><td class="markdownTableBodyNone">name </td><td class="markdownTableBodyNone">Enumeration type name.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">item </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Specifies a member of the enumeration.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">item </td><td class="markdownTableBodyNone">name </td><td class="markdownTableBodyNone">Specifies the name of the enumeration member.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">item </td><td class="markdownTableBodyNone">value </td><td class="markdownTableBodyNone">Assigns a value to the enumeration member. Member values in the enumeration follow C enumeration rules if not specified.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">item </td><td class="markdownTableBodyNone">comment </td><td class="markdownTableBodyNone">A comment about the member. Becomes a Doxygen tag.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">import_serializable_type </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Imports an XML definition of another serializable type for use in the definition.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">import_enum_type </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Imports an XML definition of an enumeration type.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">import_array_type </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Imports an XML definition of an array type.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">include_header </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Includes a C/C++ user-written header for member types.  </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md560"></a>
Constraints</h3>
<h4><a class="anchor" id="autotoc_md561"></a>
Ground Interfaces</h4>
<p>Serializables used for defining the interfaces for the ground system must be fully specified in XML files. Members of the serializables cannot be hand-coded types since the ground system analyzes the XML to determine the types for displaying and archiving the data. (See Section 6.6.3 for component ground interface specifications.)</p>
<h2><a class="anchor" id="autotoc_md562"></a>
XML-Specified Enumeration</h2>
<h3><a class="anchor" id="autotoc_md563"></a>
Motivation</h3>
<p>As discussed in the previous section, you can define an enumeration when specifying the type of a member of a Serializable type. For example, you can create a file <code>SwitchSerializableAi.xml</code> containing this specification:</p>
<div class="fragment"><div class="line">&lt;<span class="keywordtype">serializable</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;Switch&quot;</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">members</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">member</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;state&quot;</span>&gt;</div>
<div class="line">      &lt;<span class="keywordtype">enum</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;SwitchState&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;ENUM&quot;</span>&gt;</div>
<div class="line">        &lt;<span class="keywordtype">item</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;OFF&quot;</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;0&quot;</span>&gt;</div>
<div class="line">        &lt;<span class="keywordtype">item</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;ON&quot;</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;1&quot;</span>&gt;</div>
<div class="line">      &lt;/<span class="keywordtype">enum</span>&gt;</div>
<div class="line">    &lt;/<span class="keywordtype">member</span>&gt;</div>
<div class="line">  &lt;/<span class="keywordtype">members</span>&gt;</div>
<div class="line">&lt;/<span class="keywordtype">serializable</span>&gt;</div>
</div><!-- fragment --><p>This file defines a Serializable type <code>Switch</code> with one member <code>state</code>. Its type is <code>SwitchState</code>, which is an enumeration with enumerated constants <code>OFF</code> and <code>ON</code>.</p>
<p>Alternatively, you can specify an enumeration <em>E</em> as a separate XML type. Then you can do the following:</p>
<ol type="1">
<li>Generate a C++ representation of <em>E</em> that you can include in C++ files and use on its own.</li>
<li>Use the XML representation of <em>E</em> in Serializable XML types, in Array XML types, in port arguments, in telemetry channels, and in event arguments.</li>
</ol>
<p>As an example, you can create a file <code>SwitchStateEnumAi.xml</code> that specifies an XML enumeration type <code>SwitchState</code> with enumerated constants <code>OFF</code> and <code>ON</code>, like this:</p>
<div class="fragment"><div class="line">&lt;<span class="keywordtype">enum</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;SwitchState&quot;</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">item</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;OFF&quot;</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;0&quot;</span>/&gt;</div>
<div class="line">  &lt;<span class="keywordtype">item</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;ON&quot;</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;1&quot;</span>/&gt;</div>
<div class="line">&lt;/<span class="keywordtype">enum</span>&gt;</div>
</div><!-- fragment --><p>By running the code generator on this file, you can generate C++ files <code>SwitchStateEnumAc.hpp</code> and <code>SwitchStateEnumAc.cpp</code> that define the C++ representation of the type. Anywhere that you include <code>SwitchStateEnumAc.hpp</code> in your C++ code, you can use the enumerated constants <code>SwitchState::OFF</code> and <code>SwitchState::ON</code>. If you import <code>SwitchStateEnumAi.xml</code> into another XML definition, then you can use the type <code>SwitchState</code> there.</p>
<p>To use an XML enumeration type <em>E</em> in another XML definition <em>D</em>, enclose the name of the file that defines <em>E</em> in an XML tag <code>import_enum_type</code>. As an example, you can revise the <code>Switch</code> Serializable definition shown above. Instead of defining <code>SwitchState</code> as an inline enumeration, you can use the <code>SwitchState</code> XML enumeration type as follows:</p>
<div class="fragment"><div class="line">&lt;<span class="keywordtype">serializable</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;Switch&quot;</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">import_enum_type</span>&gt;<span class="keyword">SwitchStateEnumAi.xml</span>&lt;/<span class="keywordtype">import_enum_type</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">members</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">member</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;state&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;SwitchState&quot;</span>/&gt;</div>
<div class="line">  &lt;/<span class="keywordtype">members</span>&gt;</div>
<div class="line">&lt;/<span class="keywordtype">serializable</span>&gt;</div>
</div><!-- fragment --><p>Notice that the revised version (1) imports the enum type definition from the file <code>SwitchStateEnumAi.xml</code> and (2) uses the named type <code>SwitchState</code> as the type of member <code>state</code>.</p>
<p>As another example, if you import the file <code>SwitchStateEnumAi.xml</code> into the definition of a component <em>C</em>, then you can use the type <code>SwitchState</code> in the telemetry dictionary for <em>C</em>. When a value of type <code>SwitchState</code> is emitted as telemetry, the GDS will display it symbolically as <code>OFF</code> or <code>ON</code>.</p>
<h3><a class="anchor" id="autotoc_md564"></a>
Specification</h3>
<p><b>File name:</b> An XML enumeration type <em>E</em> must be defined in a file with the name <em>E</em> <code>EnumAi.xml</code>. For example, the XML enumeration type <code>SwitchState</code> must be defined in a file named <code>SwitchStateEnumAi.xml</code>.</p>
<p><b>Top-level structure:</b> An XML enumeration type is an XML node named <code>enum</code> with attributes <em>enum_attributes</em> and children <em>enum_children</em>.</p>
<p><code>&lt;enum</code> <em>enum_attributes</em> <code>&gt;</code> <em>enum_children</em> <code>&lt;/enum&gt;</code></p>
<p><b>Enum attributes:</b> <em>enum_attributes</em> consists of the following:</p>
<ul>
<li>An attribute <code>name</code> giving the name of the enumeration type.</li>
<li>An optional attribute <code>namespace</code> giving the enclosing namespace of the enumeration type. The namespace consists of one or more identifiers separated by <code>::</code>.</li>
</ul>
<p>If the attribute <code>namespace</code> is missing, then the type is placed in the global namespace.</p>
<p><em>Examples:</em> Here is an XML enumeration <code>E</code> in the global namespace:</p>
<p><code>&lt;enum name="E"&gt;</code> ... <code>&lt;/enum&gt;</code></p>
<p>Here is an XML enumeration <code>E</code> in the namespace <code>A::B</code>:</p>
<p><code>&lt;enum name="E" namespace="A::B"&gt;</code> ... <code>&lt;/enum&gt;</code></p>
<p><b>Enum children:</b> <em>enum_children</em> consists of the following, in any order:</p>
<ul>
<li><p class="startli">An optional node <code>comment</code> containing comment text.</p>
<p class="startli"><code>&lt;comment&gt;</code> <em>comment_text</em> <code>&lt;/comment&gt;</code></p>
<p class="startli">The comment text becomes a comment in the generated C++ code. It is attached to the C++ class that defines the enumeration.</p>
</li>
<li>One or more instances of <em>item_definition</em>, described below.</li>
</ul>
<p><b>Item definition:</b> <em>item_definition</em> defines an enumerated constant. It is an XML node named <code>item</code> with the following attributes:</p>
<ul>
<li>An attribute <code>name</code> giving the name of the enumerated constant.</li>
<li>An optional attribute <code>value</code> assigning an integer value to the enumerated constant. If the <code>value</code> attribute is missing, then the value is assigned in the ordinary way for C and C++ enumerations (i.e., zero for the first constant, otherwise one more than the value assigned to the previous constant).</li>
<li>An optional attribute <code>comment</code> giving comment text. The text becomes a comment in the generated C++ code. It is attached to the enumerated constant definition.</li>
</ul>
<p><em>Examples:</em> Here is an enumerated constant with a name only:</p>
<p><code>&lt;item name="ON"/&gt;</code></p>
<p>Here is an enumerated constant with a name, value, and comment:</p>
<p><code>&lt;item name="OFF" value="0" comment="The off state"/&gt;</code></p>
<h2><a class="anchor" id="autotoc_md565"></a>
XML-Specified Array Type</h2>
<h3><a class="anchor" id="autotoc_md566"></a>
Motivation</h3>
<p>As discussed above, a member of a Serializable type can be an array of elements of some other type. For example, you can create a file <code>ACSTelemetrySerializable.xml</code> containing this specification:</p>
<div class="fragment"><div class="line">&lt;<span class="keywordtype">serializable</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;ACSTelemetry&quot;</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">members</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">member</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;attitudeError&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;F32&quot;</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">member</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;wheelSpeeds&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;U32&quot;</span> <span class="keyword">size</span>=<span class="stringliteral">&quot;3&quot;</span>&gt;</div>
<div class="line">    &lt;/<span class="keywordtype">member</span>&gt;</div>
<div class="line">  &lt;/<span class="keywordtype">members</span>&gt;</div>
<div class="line">&lt;/<span class="keywordtype">serializable</span>&gt;</div>
</div><!-- fragment --><p>This file defines a Serializable type <code>ACSTelemetry</code> with the following members:</p>
<ul>
<li>A member <code>attitudeError</code> of type <code>F32</code>.</li>
<li>A member <code>wheelSpeeds</code> whose type is an array of three values, each of type <code>U32</code>.</li>
</ul>
<p>Alternatively, you can specify a named array type <em>A</em> in a separate XML file. Then you can do the following:</p>
<ol type="1">
<li>Generate a C++ representation of <em>A</em> that you can include in C++ files and use on its own.</li>
<li>Use the XML representation of <em>A</em> in Serializable XML types, in other Array XML types, in port arguments, in telemetry channels, and in event arguments.</li>
</ol>
<p>As an example, you can create a file <code>WheelSpeedsArrayAi.xml</code> that specifies an array of three <code>U32</code> values, like this:</p>
<div class="fragment"><div class="line">&lt;<span class="keywordtype">array</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;WheelSpeeds&quot;</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">type</span>&gt;<span class="keyword">U32</span>&lt;/<span class="keywordtype">type</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">size</span>&gt;3&lt;/<span class="keywordtype">size</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">format</span>&gt;%<span class="keyword">u</span>&lt;/<span class="keywordtype">format</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">default</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">value</span>&gt;0&lt;/<span class="keywordtype">value</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">value</span>&gt;0&lt;/<span class="keywordtype">value</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">value</span>&gt;0&lt;/<span class="keywordtype">value</span>&gt;</div>
<div class="line">  &lt;/<span class="keywordtype">default</span>&gt;</div>
<div class="line">&lt;/<span class="keywordtype">array</span>&gt;</div>
</div><!-- fragment --><p>By running the code generator on this file, you can generate C++ files <code>WheelSpeedsAc.hpp</code> and <code>WheelSpeedsAc.cpp</code> that define a C++ class <code>WheelSpeeds</code> representing this type. Anywhere that you include <code>WheelSpeedsEnumAc.hpp</code> in your C++ code, you can use the class <code>WheelSpeeds</code>. If you import <code>WheelSpeedsArrayAi.xml</code> into another XML definition, then you can use the type <code>WheelSpeeds</code> there.</p>
<p>To use an XML array type <em>A</em> in another XML definition <em>D</em>, enclose the name of the file that defines <em>A</em> in an XML tag <code>import_array_type</code>. As an example, you can revise the definition of the Serializable type <code>ACSTelemetry</code> as follows:</p>
<div class="fragment"><div class="line">&lt;<span class="keywordtype">serializable</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;ACSTelemetry&quot;</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">import_array_type</span>&gt;<span class="keyword">WheelSpeedsArrayAi.xml</span>&lt;/<span class="keywordtype">import_array_type</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">members</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">member</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;attitudeError&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;F32&quot;</span>/&gt;</div>
<div class="line">    &lt;<span class="keywordtype">member</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;wheelSpeeds&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;WheelSpeeds&quot;</span>/&gt;</div>
<div class="line">  &lt;/<span class="keywordtype">members</span>&gt;</div>
<div class="line">&lt;/<span class="keywordtype">serializable</span>&gt;</div>
</div><!-- fragment --><p>This specification defines an XML Serializable type with two members:</p>
<ol type="1">
<li>Member <code>attitudeError</code> of type <code>F32</code>.</li>
</ol>
<ol type="1">
<li>Member <code>wheelSpeeds</code> of type <code>WheelSpeeds</code>.</li>
</ol>
<p>Notice that whereas before <code>wheelSpeeds</code> was directly declared as an array of three <code>U32</code> values, here it is given type <code>WheelSpeeds</code>, which is defined in a separate XML specification as an array of three <code>U32</code> values.</p>
<p>As another example, if you import file <code>WheelSpeedsArrayAi.xml</code> into the definition of a component <em>C</em>, then you can use the type <code>WheelSpeeds</code> in the telemetry dictionary for <em>C</em>. When a value of type <code>WheelSpeeds</code> is emitted as telemetry, the GDS will display it as an array of three values.</p>
<h3><a class="anchor" id="autotoc_md567"></a>
Specification</h3>
<p><b>File name:</b> An XML array type <em>A</em> must be defined in a file with the name <em>A</em> <code>ArrayAi.xml</code>. For example, the XML array type <code>WheelSpeeds</code> must be defined in a file named <code>WheelSpeedsArrayAi.xml</code>.</p>
<p><b>Top-level structure:</b> An XML array type is an XML node named <code>array</code> with attributes <em>array_attributes</em> and children <em>array_children</em>.</p>
<p><code>&lt;array</code> <em>array_attributes</em> <code>&gt;</code> <em>array_children</em> <code>&lt;/array&gt;</code></p>
<p><b>Array attributes:</b> <em>array_attributes</em> consists of the following:</p>
<ul>
<li>An attribute <code>name</code> giving the name of the array type.</li>
<li>An optional attribute <code>namespace</code> giving the enclosing namespace of the array type. The namespace consists of one or more identifiers separated by <code>::</code>.</li>
</ul>
<p>If the attribute <code>namespace</code> is missing, then the type is placed in the global namespace.</p>
<p><em>Examples:</em> Here is an XML array <code>A</code> in the global namespace:</p>
<p><code>&lt;array name="A"&gt;</code> ... <code>&lt;/array&gt;</code></p>
<p>Here is an XML array <code>A</code> in the namespace <code>B::C</code>:</p>
<p><code>&lt;array name="A" namespace="B::C"&gt;</code> ... <code>&lt;/array&gt;</code></p>
<p><b>Array children:</b> <em>array_children</em> consists of the following, in any order:</p>
<ul>
<li><p class="startli">An optional node <code>comment</code> containing comment text.</p>
<p class="startli"><code>&lt;comment&gt;</code> <em>comment_text</em> <code>&lt;/comment&gt;</code></p>
<p class="startli">The comment text becomes a comment in the generated C++ code. It is attached to the C++ class that defines the array.</p>
</li>
<li>Zero or more of any of the following nodes:<ul>
<li><code>&lt;include_header&gt;</code> <em>header_file</em> <code>&lt;/include_header&gt;</code> for including C++ header files into the generated C++.</li>
<li><code>&lt;import_serializable_type&gt;</code> <em>serializable_xml_file</em> <code>&lt;/import_serializable_type&gt;</code> for importing XML-specified serializable types.</li>
<li><code>&lt;import_enum_type&gt;</code> <em>enum_xml_file</em> <code>&lt;/import_enum_type&gt;</code> for importing XML-specified enum types.</li>
<li><code>&lt;import_array_type&gt;</code> <em>array_xml_file</em> <code>&lt;/import_array_type&gt;</code> for importing XML-specified array types.</li>
</ul>
</li>
<li><p class="startli">A node <code>format</code> providing a single format string to be applied to each array element.</p>
<p class="startli"><code>&lt;format&gt;</code> <em>format_string</em> <code>&lt;/format&gt;</code></p>
<p class="startli"><em>format_string</em> must contain a single conversion specifier starting with <code>%</code>. The conversion specifier must be legal both for C and C++ <code>printf</code> and for Python, considering the array element type. For example, if the array element type is <code>U32</code>, then <code>&lt;format&gt;u&lt;/format&gt;</code> is a valid format specifier. So is <code>&lt;format&gt;u seconds&lt;/time&gt;</code>. <code>&lt;format&gt;s&lt;/format&gt;</code> is not a legal format specifier in this case, because the string format <code>s</code> is not valid for type <code>U32</code>.</p>
</li>
<li><p class="startli">A node <code>type</code> consisting of attributes <em>type_attributes</em> and text <em>type</em>.</p>
<p class="startli"><code>&lt;type</code> <em>size_attribute_opt</em> <code>&gt;</code> <em>type</em> <code>&lt;/type&gt;</code></p>
<p class="startli"><em>size_attribute_opt</em> is an optional attribute <code>size</code> specifying a decimal integer size. The <code>size</code> attribute is valid only if the element type is <code>string</code>, and it is required in this case. It specifies the size of the string representation.</p>
<p class="startli"><em>type</em> is text specifying the type of each array element. It must be an F Prime built-in type such as <code>U32</code> or a named type. A named type is (1) the name of an XML-specified type (Serializable, Enum, or Array) or (2) the name of a C++ class included with <code>include_header</code>.</p>
<p class="startli"><em>Examples:</em></p><ul>
<li><code>&lt;type&gt;U32&lt;/type&gt;</code> specifies the built-in type <code>U32</code></li>
<li><code>&lt;type&gt;T&lt;/type&gt;</code> specifies the named type <code>T</code>. <code>T</code> must be (1) included via <code>include_header</code> or (2) imported via <code>import_serializable_type</code>, <code>import_enum_type</code>, or <code>import_array_type</code>.</li>
<li><code>&lt;type size="40"&gt;string&lt;/type&gt;</code> specifies a string type of size 40.</li>
</ul>
</li>
<li><p class="startli">A node <code>size</code> specifying the size of the array as a decimal integer.</p>
<p class="startli"><code>&lt;size&gt;</code> <em>integer</em> <code>&lt;/size&gt;</code></p>
</li>
<li><p class="startli">A node <code>default</code> with one or more child nodes <code>value</code>.</p>
<p class="startli"><code>&lt;default&gt;</code> <em>value</em> ... <code>&lt;/default&gt;</code></p>
<p class="startli">The format of <em>value</em> is described below. There must be one value for each element of the array.</p>
</li>
</ul>
<p><b>Value:</b> The node <code>value</code> specifies a default value for an array element. The value must be text that, when inserted into the generated C++ code, represents a default value of the correct type.</p>
<p><em>Examples:</em></p>
<ul>
<li>If the array element type is <code>U32</code>, then <code>0</code> is a correct default value.</li>
<li>Suppose the array element type is an array <code>A</code> of three U32 values. In the generated C++ code, <code>A</code> is a class with a three-argument constructor, and each argument initializes an array element. Therefore <code>A(1, 2, 3)</code> is a correct default value.</li>
</ul>
<h2><a class="anchor" id="autotoc_md568"></a>
Hand-coded Serializable</h2>
<p>A hand-coded serializable is useful in the case where the type is not easily expressed as a collection of basic types or if the user is employing an external library with types already defined. A user may also wish to attach special processing functions to a class. The pattern for writing C++ serializable classes is to declare a class that is derived from the framework base class <a class="el" href="class_fw_1_1_serializable.html" title="forward declaration">Fw::Serializable</a>. That type can be found in <a class="el" href="serializable_8hpp.html">Fw/Types/Serializable.hpp</a>. An example can be found in Autocoders/templates/ExampleType.hpp. The method is as follows:</p>
<ol type="1">
<li>Define the class. It should be derived from <a class="el" href="class_fw_1_1_serializable.html" title="forward declaration">Fw::Serializable</a>.</li>
</ol>
<ol type="1">
<li>Declare the two base class pure virtual functions: serialize() and deserialize(). These functions provide a buffer as a destination for the serialized form of the data in the type.</li>
</ol>
<ol type="1">
<li>Implement the functions. The buffer base class that is the argument to those functions provides a number of helper functions for serializing and deserializing the basic types in the table above. Those functions are specified in the SerializeBufferBase class type in the same header file. For each member that the developer wishes to save, call the serialization functions. The members can be serialized in any order. In the worst case, a raw buffer version is provided for just doing a bulk copy of the data if serializing individual members is not feasible. The deserialization function should deserialize the data in the order it was serialized.</li>
</ol>
<ol type="1">
<li>Add an enumeration with a single member named SERIALIZED_SIZE. The value of that member should be the sum of the sizes of all the members. It can be done with the sizeof() function that is available to all C/C++ compilers. Optionally, a type identifier can be added so that a sanity check can be done when the data are deserialized. That type should be serialized, and then checked against the enumeration when it is deserialized.</li>
</ol>
<ol type="1">
<li>Implement copy constructors and equal operators. If the type is passed by value, the developer should write these functions if the default is not sufficient.</li>
</ol>
<ol type="1">
<li>Implement any custom features.</li>
</ol>
<p>Once the class is completed, it can be included in port definitions.</p>
<h3><a class="anchor" id="autotoc_md569"></a>
Constraints</h3>
<h4><a class="anchor" id="autotoc_md570"></a>
Ground Interfaces</h4>
<p>Hand-coded user types cannot be used in XML definitions for types that will be sent to and from the ground system, since the ground system requires all type definitions to be in XML. If a developer wants to use a type that has special functions in a ground interface, it can be defined with the members only in XML and generated by the code generator. The developer can then define a derived class with the behavior.</p>
<h1><a class="anchor" id="autotoc_md571"></a>
Port</h1>
<p>Ports are the interfaces between components. Components invoke functionality in other components by invoking methods on their output ports instead of invoking the components directly. Input ports invoke methods defined by the components and registered at run time. Ports are fully specified in XML files. There is no developer-written code, but the XML specifications can include argument types defined by the user as long as they are serializable as described in Section 6.6.1.2. The process of defining a port is to specify the arguments to the method in the XML file. In order for the build system to detect that a file contains the XML for a port type, the file must follow the naming convention &lt;SomeName&gt;PortAi.xml. An example of this can be found in Autocoders/templates/ExamplePortAi.xml. Table 17 describes the XML tags and attributes.</p>
<p><b>Table 17.</b> Port XML specification.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Tag </th><th class="markdownTableHeadNone">Attribute </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">interface </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">The outermost tag that indicates a port is being defined.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">interface </td><td class="markdownTableBodyNone">namespace </td><td class="markdownTableBodyNone">The C++ namespace for the port class (optional).  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">interface </td><td class="markdownTableBodyNone">name </td><td class="markdownTableBodyNone">The class name for the port.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">comment </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Used for a comment describing the port. Is placed as a Doxygen-compatible tag in the class declaration.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">args </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Optional. Starts the region of the declaration where port arguments are specified.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">arg </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Defines an argument to the port method.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">arg </td><td class="markdownTableBodyNone">type </td><td class="markdownTableBodyNone">The type of the argument. Should be a built-in type, ENUM, string, an XML-specified type, or a user-written serializable type. A string type should be used if a text string is the argument. If the type is serial, the port is an untyped serial port that can be connected to any typed port for the purpose of serializing the call. See the Hub pattern in the architectural description document for a usage.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">arg </td><td class="markdownTableBodyNone">name </td><td class="markdownTableBodyNone">Defines the argument name.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">arg </td><td class="markdownTableBodyNone">size </td><td class="markdownTableBodyNone">Specifies the size of the argument if it is of type string.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">arg </td><td class="markdownTableBodyNone">pass_by </td><td class="markdownTableBodyNone">Optional. Specifies if the argument should be passed by reference or pointer. Default is to pass by value. Values can be VALUE, POINTER, or REFERENCE. This is provided as an optimization to avoid unnecessary copies. When arguments to ports with references are detected by components, the argument is serialized in the same way as an argument that is passed by value. If it is passed by pointer, the pointer value is copied and not the contents of the type instance pointed to by the pointer. This carries the usual responsibility for understanding the scope and lifetime of the memory behind the pointer, as the pointer value may be held by another component past the duration of the port call.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">enum </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Specifies an enumeration when the argument type=ENUM.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">enum </td><td class="markdownTableBodyNone">name </td><td class="markdownTableBodyNone">Enumeration type name.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">item </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Specifies a member of the enumeration.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">item </td><td class="markdownTableBodyNone">name </td><td class="markdownTableBodyNone">Specifies the name of the enumeration member.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">item </td><td class="markdownTableBodyNone">value </td><td class="markdownTableBodyNone">Assigns a value to the enumeration member. Member values in the enumeration follow C enumeration rules if not specified.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">item </td><td class="markdownTableBodyNone">comment </td><td class="markdownTableBodyNone">A comment about the member. Becomes a Doxygen tag.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">return </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Optional. Specifies that the method will return a value.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">return </td><td class="markdownTableBodyNone">type </td><td class="markdownTableBodyNone">Specifies the type of the return. Can be a built-in type.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">return </td><td class="markdownTableBodyNone">pass_by </td><td class="markdownTableBodyNone">Specifies whether the argument should be passed by value or by reference or pointer.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">import_serializable_type </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Imports an XML definition of another serializable type for use in the definition.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">import_enum_type </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Imports an XML definition of an enumeration type.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">import_array_type </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Imports an XML definition of an array type.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">include_header </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Includes a C/C++ user-written header for argument types.  </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md572"></a>
Constraints</h2>
<p>The following constraints are on port XML definitions.</p>
<h3><a class="anchor" id="autotoc_md573"></a>
Serialization</h3>
<p>Port calls are serialized for various reasons by components, such as for copying data to put on a message queue. A port call cannot be serialized if it contains return values, since the serialized arguments are passed only to the connected port or component and no return data are provided.</p>
<h1><a class="anchor" id="autotoc_md574"></a>
Components</h1>
<p>Components are the places in the architecture where all the behavior resides. Incoming port calls deliver data and actions to be acted on, and output ports are used to invoke functions outside the component. In addition, the components define the interfaces used to communicate with ground software. Components can be used for a variety of purposes such as hardware drivers, state machines, device managers, and data management. The process of defining a component is to specify the ports and ground data interfaces in XML. The developer then implements a derived class that inherits from the base class and implements the interfaces as methods in the class (see Section 6.7). In order for the build system to detect that a file contains the XML for a component type, the file must follow the naming convention &lt;SomeName&gt;ComponentAi.xml. An example of this can be found in Autocoders/templates/ExampleComponentAi.xml. Table 18 describes the XML tags and attributes.</p>
<p><b>Table 18.</b> Component XML specification.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Tag </th><th class="markdownTableHeadNone">Attribute </th><th class="markdownTableHeadNone">Description </th><th class="markdownTableHeadNone"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">component </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">The outermost tag that indicates a component is being defined. </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">component </td><td class="markdownTableBodyNone">namespace </td><td class="markdownTableBodyNone">The C++ namespace for the component class (optional). </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">component </td><td class="markdownTableBodyNone">name </td><td class="markdownTableBodyNone">The class name for the component. </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">component </td><td class="markdownTableBodyNone">kind </td><td class="markdownTableBodyNone">The type of component. Can be passive, queued, or active. A passive component has no thread or queue. A queued component has a message queue, but no thread. A component on another thread must invoke a synchronous input interface (see below) to get messages from the queue. An active component has a thread, and unloads its message queue as the thread is scheduled and as port invocation messages arrive. </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">component </td><td class="markdownTableBodyNone">modeler </td><td class="markdownTableBodyNone">When the attribute is “true,” the autocoder does not automatically create ports for commands, telemetry, events, and parameters. If it is “true,” those ports must be declared in the port section with the “role” attribute. See description below. </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">import_dictionary </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Imports a ground dictionary defined outside the component XML that conforms to the command, telemetry, event, and parameter entries below. This allows external tools written by projects to generate dictionaries. </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">import_port_type </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Imports an XML definition of a port type used by the component. </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">import_serializable_type </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Imports an XML definition of a serializable type for use in the component interfaces. </td><td class="markdownTableBodyNone"></td></tr>
</table>
<p>| import_enum_type | | Imports an XML definition of an enumeration type.| | import_array_type | | Imports an XML definition of an array type.| | comment | | Used for a comment describing the component. Is placed as a Doxygen-compatible tag in the class declaration. | | | ports | | Defines the section of the component definition where ports are defined. | | | port | | Starts the description of a port. | | | port | name | Defines the name of the port. | | | port | data_type | Defines the type of the port. The XML file containing the type of the port must be provided via the import_port_type tag. | | | port | kind | Defines the synchronicity and direction of the port. The port can be of the following kinds: | | | | | <b>Kind</b> | <b>Attributes</b> | | | | sync_input | Invokes the derived class methods directly. | | | | guarded_input | Invokes the derived class methods after locking a mutex shared by all guarded ports and commands. | | | | async_input | Creates a message with the serialized arguments of the port call. When the message is dequeued, the arguments are deserialized and the derived class method is called. | | | | output | Port is an output port that is invoked from the logic in the derived class. | | port | priority | The priority of the invocation. Only used for asynchronous ports, and specifies the priority of the message in the underlying message queue if priorities are supported by the target OS. Range is OS dependent. | | | port | max_number | Specifies the number of ports of this type. This allows multiple callers to the same type of port if knowing the source is necessary. Can be specified as an Fw/Cfg/AcConstants.ini file $VARIABLE value. | | | port | full | Specifies the behavior for async ports when the message queue is full. One of <em>drop</em>, <em>block</em>, or <em>assert</em>, where <em>assert</em> is the default. | | | port | role | Specifies the role of the port when the modeler=true. | | | commands | | Optional. Starts the section where software commands are defined. | | | commands | opcode_base | Defines the base value for the opcodes in the commands. If this is specified, all opcodes will be added to this value. If it is missing, opcodes will be absolute. This tag can also have a variable of the form $VARIABLE referring to values in Fw/Cfg/AcConstants.ini. | | | command | | Starts the definition for a particular command. | | | command | mnemonic | Defines a text label for the command. Can be alphanumeric with “_” separators, but no spaces. | | | command | opcode | Defines an integer that represents the opcode used to decode the command. Should be a C-compilable constant. | | | command | kind | Defines the synchronicity of the command. The command can be of the following kinds: | | | | | <b>Kind</b> | <b>Attributes</b> | | | | sync | Invokes the derived class methods directly. | | | | guarded | Invokes the derived class methods after locking a mutex shared by all guarded ports and commands. | | | | async | Creates a message with the serialized arguments of the port call. When the message is dequeued, the arguments are deserialized and the derived class method is called. | | command | priority | Sets command message priority if message is asynchronous, ignored otherwise. | | | command | full | Specifies the behavior for async commands when the message queue is full. One of <em>drop</em>, <em>block</em>, or <em>assert</em>, where <em>assert</em> is the default. | | | args | | Optional. Starts the region of the declaration where command arguments are specified. | | | arg | | Defines an argument in the command. | | | arg | type | The type of the argument. Should be a built-in type. A string type should be used if a text string is the argument. | | | arg | name | Defines the argument name. | | | arg | size | Specifies the size of the argument if it is of type string. | | | enum | | Specifies an enumeration when the argument type=ENUM. | | | enum | name | Enumeration type name. | | | item | | Specifies a member of the enumeration. | | | item | name | Specifies the name of the enumeration member. | | | item | value | Assigns a value to the enumeration member. Member values in the enumeration follow C enumeration rules if not specified. | | | item | comment | A comment about the member. Becomes a Doxygen tag. | | | telemetry | | Optional. Specifies the section that defines the channelized telemetry. | | | telemetry | telemetry_base | Defines the base value for the channel IDs. If this is specified, all channel IDs will be added to this value. If it is missing, channel IDs will be absolute. This tag can also have a variable of the form $VARIABLE referring to values in Fw/Cfg/AcConstants.ini. | | | channel | | Starts the definition for a telemetry channel. | | | channel | id | Specifies a numerical value identifying the channel. | | | channel | name | A text string with the channel name. Cannot contain spaces. | | | channel | data_type | Specifies the type of the channel. Should be a built-in type, ENUM, string, or an XML-specified serializable. A string type should be used if a text string is the argument. | | | channel | size | If the channel type is string, specifies the size of the string. | | | channel | abbrev | An abbreviation for the channel. Needed for the AMMOS Mission Data Processing and Control System (AMPCS), a ground data system to display telemetry and events from spacecraft. | | | channel | update | If the channel should be always updated, or only on change. Values are ALWAYS or ON_CHANGE. | | | channel | format_string | A format string specifier for displaying the channel value. | | | comment | | A comment describing the channel. | | | enum | | Specifies an enumeration when the channel type=ENUM. | | | enum | name | Enumeration type name. | | | item | | Specifies a member of the enumeration. | | | item | name | Specifies the name of the enumeration member. | | | item | value | Assigns a value to the enumeration member. Member values in the enumeration follow C enumeration rules if not specified. | | | item | comment | A comment about the member. Becomes a Doxygen tag. | | | parameters | | Optional. Specifies the section that defines parameters for the component. | | | parameters | parameter_base | Defines the base value for the parameter IDs. If this is specified, all parameter IDs will be added to this value. If it is missing, parameter IDs will be absolute. This tag can also have a variable of the form $VARIABLE referring to values in Fw/Cfg/AcConstants.ini. | | | parameters | opcode_base | Defines the base value for the opcodes in the parameter set and save commands. If this is specified, all opcodes will be added to this value. If it is missing, opcodes will be absolute. This tag can also have a variable of the form $VARIABLE referring to values in Fw/Cfg/AcConstants.ini. | | | parameter | | Starts the definition for a parameter. | | | parameter | id | Specifies a numeric value that represents the parameter. | | | parameter | name | Specifies the name of the parameter. | | | parameter | data_type | Specifies the type of the parameter. Should be a built-in type, ENUM, string, or an XML-specified serializable. A string type should be used if a text string is the argument. | | | parameter | size | Specifies the size of the parameter if it is of type string. | | | parameter | default | Specifies a default value for the parameter if the parameter is unable to be retrieved from non-volatile storage. Only for built-in types. | | | parameter | comment | A comment describing the parameter. | | | parameter | set_opcode | Command opcode used to set parameter. | | | parameter | save_opcode | Command opcode used to save parameter. | | | enum | | Specifies an enumeration when the parameter type=ENUM. | | | enum | name | Enumeration type name. | | | item | | Specifies a member of the enumeration. | | | item | name | Specifies the name of the enumeration member. | | | item | value | Assigns a value to the enumeration member. Member values in the enumeration follow C enumeration rules if not specified. | | | item | comment | A comment about the member. Becomes a Doxygen tag. | | | events | | Optional. Specifies the section that defines events for the component. | | | events | event_base | Defines the base value for the event IDs. If this is specified, all event IDs will be added to this value. If it is missing, event IDs will be absolute. This tag can also have a variable of the form $VARIABLE referring to values in Fw/Cfg/AcConstants.ini. | | | event | | Starts the definition for an event. | | | event | id | Specifies a numeric value that represents the event. | | | event | name | Specifies the name of the event. | | | event | severity | Specifies the severity of the event. The values can be: | | | | | <b>Value</b> | <b>Meaning</b> | | | | DIAGNOSTIC | Software debugging information. Meant for development. | | | | ACTVITY_LO | Low-priority events related to software execution. | | | | ACTVITY_HI | Higher priority events related to software execution. | | | | COMMAND | Events related to command execution. Should be reserved for command dispatcher and sequencer. | | | | WARNING_LO | Error conditions that are of low importance. | | | | WARNING_LO | Error conditions that are of critical importance. | | | | FATAL | An error condition was encountered that the software cannot recover from. | | event | format_string | A C-style format string to print a message corresponding to the event. Used for displaying the event in the command/data handling software as well as the optional text logging in the software. (See Section 9.12.) | | | comment | | A comment describing the event. | | | args | | Starts the region of the declaration where event arguments are specified. | | | arg | | Defines an argument in the event. | | | arg | type | The type of the argument. Should be a built-in type, ENUM, string, or an XML-specified serializable. A string type should be used if a text string is the argument. | | | arg | name | Defines the argument name. | | | arg | size | Specifies the size of the argument if it is of type string. | | | internal_interfaces | | Optional. Specifies an internal interface for the component. Internal interfaces are functions that can be called internally from implementation code. These functions will dispatch a message in the same fashion that asynchronous ports and commands do. The developer implements a handler in the same way, and that handler is called on the thread of an active or queued component. Internal interfaces cannot be specified for a passive component since there is not message queue. A typical use for an internal interface would be for an interrupt service routine. | | | internal_interface | | Specifies an internal interface call. | | | internal_interface | priority | Sets internal interface message priority if message is asynchronous, ignored otherwise. | | | internal_interface | full | Specifies the behavior for internal interfaces when the message queue is full. One of <em>drop</em>, <em>block</em>, or <em>assert</em>, where <em>assert</em> is the default. | | | comment | | A comment describing the interface. | | | args | | Starts the region of the declaration where interface arguments are specified. | | | arg | | Defines an argument in the interface. | | | arg | type | The type of the argument. Should be a built-in type, ENUM, string, or an XML-specified serializable. A string type should be used if a text string is the argument. | | | arg | name | Defines the argument name. | | | arg | size | Specifies the size of the argument if it is of type string. | |</p>
<p><b>NOTE:</b> This table describes the hierarchical XML structure. Repeated rows are usable under multiple different parents, in the same format. For example, commands can define inner enumeration elements, events can define enumerations, and channels can define enumerations. Thus, some rows are repeated to show that this is possible.</p>
<h2><a class="anchor" id="autotoc_md575"></a>
Constraints</h2>
<p>The following constraints are on components.</p>
<h3><a class="anchor" id="autotoc_md576"></a>
Passive Components</h3>
<p>Passive components cannot have asynchronous input ports or commands, since there is no queue for messaging.</p>
<h3><a class="anchor" id="autotoc_md577"></a>
Queued Components</h3>
<p>Queued components must have at least one synchronous or guarded input port or synchronous command so that a calling thread can use the port to retrieve port call messages from the message queue.</p>
<p>Queued components must have at least one asynchronous input port, command, or internal interface, or there would be no purpose in making the component queued.</p>
<h3><a class="anchor" id="autotoc_md578"></a>
Active Components</h3>
<p>Active components must have at least one asynchronous input port, command, or internal interface, or there would be no purpose in making the component active or have a message queue.</p>
<h3><a class="anchor" id="autotoc_md579"></a>
Command and Telemetry Interfaces</h3>
<p>The component XML is parsed by the command and telemetry system in order to construct the data storage and display application. For this reason, only the built-in types or types represented in XML can be used.</p>
<h1><a class="anchor" id="autotoc_md580"></a>
Command/Telemetry Ports</h1>
<p>When declaring commands, telemetry, events, and parameters for a component, the code generator automatically creates the correct set of ports for those interfaces. Those ports are based on normal XML definitions of ports, so those port types can be used as normal ports in other components. As an example, if a component needs to implement commands, the XML would declare those commands as shown in Table 1. Another component needs to act as a command dispatcher to send commands to that component, so the dispatcher component would add an output port of the command type. The dispatcher is handling commands as a generic port invocation rather than deserializing the command arguments as the generated code does in the component that declares the commands. This allows writing components to process commands and telemetry generically without having to treat command and telemetry ports as special cases. The port definition XML files can be included in component XML definitions in the same manner as other ports. Table 19 provides a list of the types, file names, and descriptions of the ports used for the command and telemetry ports.</p>
<p><b>Table 19.</b> Port types.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Port Type </th><th class="markdownTableHeadNone">XML File </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Commands</b> </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Command </td><td class="markdownTableBodyNone">Fw/Cmd/CmdPortAi.xml </td><td class="markdownTableBodyNone">A port that passes a serialized command to a component.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Command Response </td><td class="markdownTableBodyNone">Fw/Cmd/CmdResponsePortAi.xml </td><td class="markdownTableBodyNone">A port that passes the completion status of a command.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Command Registration </td><td class="markdownTableBodyNone">Fw/Cmd/CmdRegPortAi.xml </td><td class="markdownTableBodyNone">A port used to request registration of a command. Used during initialization to tell a command dispatcher where to send specific opcodes.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Telemetry</b> </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Telemetry </td><td class="markdownTableBodyNone">Fw/Tlm/TlmPortAi.xml </td><td class="markdownTableBodyNone">A port that passes a serialized telemetry value.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Time </td><td class="markdownTableBodyNone">Fw/Time/TimePortAi.xml </td><td class="markdownTableBodyNone">A port that returns a time value for time stamping the telemetry.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Events</b> </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Log </td><td class="markdownTableBodyNone">Fw/Log/LogPortAi.xml </td><td class="markdownTableBodyNone">A port that passes a serialized event.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">LogText </td><td class="markdownTableBodyNone">Fw/Log/LogTextPortAi.xml </td><td class="markdownTableBodyNone">A port that passes the text form of an event. Can be disabled via configuration of the architecture.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Time </td><td class="markdownTableBodyNone">Fw/Time/TimePortAi.xml </td><td class="markdownTableBodyNone">A port that returns a time value for time stamping the telemetry.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Parameters</b> </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Parameter </td><td class="markdownTableBodyNone">Fw/Prm/PrmPortAi.xml </td><td class="markdownTableBodyNone">A port that returns a serialize parameter value  </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md581"></a>
Topologies</h1>
<p>The topology (or interconnection) of components can be implemented by interconnecting them manually (see Section 6.8) or by specifying them via a topology XML file. An example of this can be seen in Ref/Top/RefTopologyAppAi.xml. The file will be processed by the autocoder if it has the ending AppAi.xml. Table 20 provides the XML specification for topologies.</p>
<p><b>Table 20.</b> Topology XML specification.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Tag </th><th class="markdownTableHeadNone">Attribute </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">deployment </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">The outermost tag that indicates a topology is being defined.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">assembly </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Alternate declaration for deployment.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">deployment </td><td class="markdownTableBodyNone">name </td><td class="markdownTableBodyNone">The name of the deployment.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">import_component_type </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Imports the XML file that defines a component used in the topology.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">instance </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Defines a component instance.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">instance </td><td class="markdownTableBodyNone">name </td><td class="markdownTableBodyNone">Name of the component instance. This instance name must match a component object declared in the C++ code.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">instance </td><td class="markdownTableBodyNone">namespace </td><td class="markdownTableBodyNone">C++ namespace of component implementation type.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">instance </td><td class="markdownTableBodyNone">type </td><td class="markdownTableBodyNone">C++ type of implementation class  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">instance </td><td class="markdownTableBodyNone">base_id </td><td class="markdownTableBodyNone">The starting ID value for commands, events, and telemetry for this instance of the component. Used to construct dictionary for ground system.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">instance </td><td class="markdownTableBodyNone">base_id_window </td><td class="markdownTableBodyNone">A bookkeeping attribute that the modeler uses to space out the base_id values. It can be omitted if the base_ids are spaced enough to cover the id range in the component.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">connection </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Defines a connection between two component ports.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">connection </td><td class="markdownTableBodyNone">name </td><td class="markdownTableBodyNone">Name of connection.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">source </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Defines the source of the connection.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">source </td><td class="markdownTableBodyNone">component </td><td class="markdownTableBodyNone">Defines source component. Must match an instance in instance section above.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">source </td><td class="markdownTableBodyNone">port </td><td class="markdownTableBodyNone">Defines source port on component.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">source </td><td class="markdownTableBodyNone">type </td><td class="markdownTableBodyNone">Source port type.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">source </td><td class="markdownTableBodyNone">num </td><td class="markdownTableBodyNone">Source port number if multiple port instances.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">target </td><td class="markdownTableBodyNone">component </td><td class="markdownTableBodyNone">Defines target component. Must match an instance in instance section above.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">target </td><td class="markdownTableBodyNone">port </td><td class="markdownTableBodyNone">Defines target port on component.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">target </td><td class="markdownTableBodyNone">type </td><td class="markdownTableBodyNone">Target port type.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">target </td><td class="markdownTableBodyNone">num </td><td class="markdownTableBodyNone">Target port number if multiple port instances.  </td></tr>
</table>
<p>The autocoder will output a source file and header file following the convention &lt;Deployment Name&gt;AppAc.cpp and .hpp. The header file contains a function named construct&lt;architecture&gt;Architecture. This function will call all the connection methods to connect the components. The file requires a header Components.hpp in the directory where the XML is defined that has declarations for the implementation class instances in the connections.</p>
<h2><a class="anchor" id="autotoc_md582"></a>
Constraints</h2>
<p>The XML specification for the component requires static declaration of component instances that can be referred to by their object name. If components are instantiated in other ways such as a heap, the manual method can be used. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
