<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>F´ Flight Software - C/C++ Documentation: F´ GPS Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">F´ Flight Software - C/C++ Documentation
   &#160;<span id="projectnumber">NASA-v1.6.0</span>
   </div>
   <div id="projectbrief">A framework for building embedded system applications to NASA flight quality standards.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_docs_v1_85__tutorials__gps_tutorial__tutorial.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">F´ GPS Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this guide, we will cover the basics of working with F´ by attaching a GPS receiver to a serial driver and running the application on a Raspberry PI. In order to fully benefit from this tutorial, the user should acquire any NMEA compatible UART GPS receiver and a raspberry pi. In this tutorial, we use a NMEA GPS receiver with micro-USB such that the code may be run on both the laptop and the Raspberry PI.</p>
<p>In the DIY electronics community there is an abundance of cheap GPS receivers based around the NMEA protocol. These receivers may support a USB interface pretending to be an ACM device for basic serial communication. The messages these receivers send are NMEA formatted ASCII text.</p>
<p><img src="img/usb-gps.jpg" alt="USB GPS Hardware" class="inline"/></p>
<p>This tutorial will show how to integrate one of these GPS receivers with the F´ framework by wrapping it in a Component and defining commands, telemetry, and log events. We will create a GpsApp deployment for the Component where it will be wired to a standard UART driver in order to receive messages. Then we can cross compile it for the Raspberry PI and run the application against the F´ ground system.</p>
<p><b>Note:</b> A completed version of this tutorial app is available <a href="https://github.com/fprime-community/gps-tutorial">here</a> for use as a demo or to help debug issues that come up when going through the tutorial.</p>
<h1><a class="anchor" id="autotoc_md43"></a>
Prerequisites</h1>
<p>This tutorial requires the user to have some basic software skills and have installed F´. The prerequisite skills to understand this tutorial are as follows:</p>
<p>1) Working knowledge of Unix; how to navigate in a shell and execute programs 2) An understanding of C++, including class declarations and inheritance 3) An understanding of how XML is structured 4) An understanding of the raspberry pi, specifically SSHing into the pi and running applications</p>
<p>Installation can be done by following the installation guide found at: ../../INSTALL.md "INSTALL.md". This guide will walk the user through the installation process and verifying the installation. In addition, users may wish to follow the ../GettingStarted/Tutorial.md "Getting Started Tutorial" in order to get a feel for the F´ environment and tools.</p>
<h1><a class="anchor" id="autotoc_md44"></a>
Creating a Custom F´ Component</h1>
<p>In this next section we will create a custom F´ component for reading GPS data off a UART based GPS module. It will receive data from a UART read port, process the data, and report telemetry from that data. We will then finish up by adding an event to report GPS lock status when it changes and a command to report lock status on demand.</p>
<p>Our custom component has the following functional block diagram:</p>
<p><img src="img/gps-comp.png" alt="GPS Component Diagram" class="inline"/></p>
<p><b>Note:</b> there are a few other ports our component will need to wire to other components in the system, the above diagram captures the ports needed for our desired functionality.</p>
<h2><a class="anchor" id="autotoc_md45"></a>
Designing the GPS Component</h2>
<p>The F’ designs are specified by XML files that are processed by code generators to create C++ source and header files. An XML file represents a single entity in the F´ system (Component, Port, Serializable, or Deployment). Command, Event, and Telemetry Channel specifications are also written in XML. Further information is in the full F´ user guide. <a href="../../UsersGuide/FprimeUserGuide.pdf">User Guide</a>. This application does not need any custom ports, as we are using the standard ports to create our GPS handler. Custom ports can be seen in the ../MathComponent/Tutorial.md "Math Component Tutorial".</p>
<p>In this section we will create a directory for our GPS component, and design the component through XML. The first step to making the component is to make a project directory to hold our project, and a component subdirectory for our GPS.</p>
<div class="fragment"><div class="line">cd fprime</div>
<div class="line">mkdir -p GpsApp/Gps</div>
<div class="line">cd GpsApp/Gps</div>
</div><!-- fragment --><p>All files in this component section will be created in the <code>Gps</code> subdirectory.</p>
<p>Next, in the GPS subdirectory, we will create a file called <em>GpsComponentAi.xml</em> filled with the below text. This represents our component's design by defining the ports it uses to connect with other components and the files used to specify commands, telemetry, and events. As can be seen, we are creating our component with 8 ports, the 4 functional ports defined above, and 4 additional ports described below:</p>
<ol type="1">
<li><b>cmdIn</b>: an input port of <em>Fw::Cmd</em> type used to process commands sent to this component.</li>
<li><b>cmdRegOut</b>: an output port of <em>Fw::CmdReg</em> type used to register this component's with the command dispatcher</li>
<li><b>cmdResponseOut</b>: an output port of <em>Fw::CmdResponse</em> type used respond to dispatched commands</li>
<li><b>eventOut</b>: an output port of <em>Fw::Log</em> type used to send events out</li>
<li><b>textEventOut</b>: an output port of <em>Fw::LogText</em> type used to send events in a text form</li>
<li><b>tlmOut</b>: an output port of <em>Fw::Tlm</em> type used to send out telemetry channels</li>
<li><b>serialRecv</b>: an input port of type <em>Drv::SerialRead</em> used to receive serial data buffers,</li>
<li><b>serialBufferOut</b>: an output port of type <em>Fw::BufferSend</em> used at startup to supply buffers to the serial driver</li>
</ol>
<p>Input ports are invoked from external components, and must be handled by the component. Output ports are used by this component to invoke actions of other components. Here <b>cmdIn</b> and <b>serialRecv</b> are inputs for commands and serial data respectively. Each will define a handler (seen later) to handle these invocations. All other ports are used to invoke other components to send data buffers, events, telemetry, etc.</p>
<p>The <code>GpsComponentAi.xml</code> file in the <code>Gps</code> subdirectory should look like: </p><div class="fragment"><div class="line">&lt;?<span class="keyword">xml</span> <span class="keyword">version</span>=<span class="stringliteral">&quot;1.0&quot;</span> <span class="keyword">encoding</span>=<span class="stringliteral">&quot;UTF-8&quot;</span>?&gt;</div>
<div class="line">&lt;?<span class="keyword">xml-model</span> <span class="keyword">href</span>=<span class="stringliteral">&quot;../../Autocoders/schema/ISF/component_schema.rng&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;application/xml&quot;</span> <span class="keyword">schematypens</span>=<span class="stringliteral">&quot;http://relaxng.org/ns/structure/1.0&quot;</span>?&gt;</div>
<div class="line"><span class="comment">&lt;!-- GPS Tutorial: GpsComponentAi.xml</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">This is the design of GPS component. The goal is to read GPS messages from a UART port, and produce Events, and</span></div>
<div class="line"><span class="comment">Telemetry that represent the GPS link. This will also have a command to emit the lock status of the GPS signal. This</span></div>
<div class="line"><span class="comment">is an active component, meaning it will have it&#39;s own thead. It will therefore process messages at its own pace, and</span></div>
<div class="line"><span class="comment">will not need an external thread of execution to run on.</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">It has 3 standard command ports, 2 standard event ports, 1 standard telemetry port, and 2 ports to interact with the</span></div>
<div class="line"><span class="comment">serial driver.</span></div>
<div class="line"><span class="comment">--&gt;</span></div>
<div class="line"> </div>
<div class="line">&lt;<span class="keywordtype">component</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;Gps&quot;</span> <span class="keyword">kind</span>=<span class="stringliteral">&quot;active&quot;</span> <span class="keyword">namespace</span>=<span class="stringliteral">&quot;GpsApp&quot;</span> <span class="keyword">modeler</span>=<span class="stringliteral">&quot;true&quot;</span>&gt;</div>
<div class="line">    <span class="comment">&lt;!-- Import command ports --&gt;</span></div>
<div class="line">    &lt;<span class="keywordtype">import_port_type</span>&gt;<span class="keyword">Fw</span>/<span class="keyword">Cmd</span>/<span class="keyword">CmdPortAi.xml</span>&lt;/<span class="keywordtype">import_port_type</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">import_port_type</span>&gt;<span class="keyword">Fw</span>/<span class="keyword">Cmd</span>/<span class="keyword">CmdRegPortAi.xml</span>&lt;/<span class="keywordtype">import_port_type</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">import_port_type</span>&gt;<span class="keyword">Fw</span>/<span class="keyword">Cmd</span>/<span class="keyword">CmdResponsePortAi.xml</span>&lt;/<span class="keywordtype">import_port_type</span>&gt;</div>
<div class="line">    <span class="comment">&lt;!-- Import event ports --&gt;</span></div>
<div class="line">    &lt;<span class="keywordtype">import_port_type</span>&gt;<span class="keyword">Fw</span>/<span class="keyword">Log</span>/<span class="keyword">LogPortAi.xml</span>&lt;/<span class="keywordtype">import_port_type</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">import_port_type</span>&gt;<span class="keyword">Fw</span>/<span class="keyword">Log</span>/<span class="keyword">LogTextPortAi.xml</span>&lt;/<span class="keywordtype">import_port_type</span>&gt;</div>
<div class="line">    <span class="comment">&lt;!-- Import telemetry ports --&gt;</span></div>
<div class="line">    &lt;<span class="keywordtype">import_port_type</span>&gt;<span class="keyword">Fw</span>/<span class="keyword">Tlm</span>/<span class="keyword">TlmPortAi.xml</span>&lt;/<span class="keywordtype">import_port_type</span>&gt;</div>
<div class="line">    <span class="comment">&lt;!-- Import ports for serial driver --&gt;</span></div>
<div class="line">    &lt;<span class="keywordtype">import_port_type</span>&gt;<span class="keyword">Drv</span>/<span class="keyword">SerialDriverPorts</span>/<span class="keyword">SerialReadPortAi.xml</span>&lt;/<span class="keywordtype">import_port_type</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">import_port_type</span>&gt;<span class="keyword">Fw</span>/<span class="keyword">Buffer</span>/<span class="keyword">BufferSendPortAi.xml</span>&lt;/<span class="keywordtype">import_port_type</span>&gt;</div>
<div class="line">    <span class="comment">&lt;!-- Import command, telemetry, and event dictionaries --&gt;</span></div>
<div class="line">    &lt;<span class="keywordtype">import_dictionary</span>&gt;<span class="keyword">GpsApp</span>/<span class="keyword">Gps</span>/<span class="keyword">Commands.xml</span>&lt;/<span class="keywordtype">import_dictionary</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">import_dictionary</span>&gt;<span class="keyword">GpsApp</span>/<span class="keyword">Gps</span>/<span class="keyword">Telemetry.xml</span>&lt;/<span class="keywordtype">import_dictionary</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">import_dictionary</span>&gt;<span class="keyword">GpsApp</span>/<span class="keyword">Gps</span>/<span class="keyword">Events.xml</span>&lt;/<span class="keywordtype">import_dictionary</span>&gt;</div>
<div class="line"> </div>
<div class="line">    &lt;<span class="keywordtype">ports</span>&gt;</div>
<div class="line">        <span class="comment">&lt;!-- Command port definitions: command input receives commands, command reg out, and response out are</span></div>
<div class="line"><span class="comment">        ports used to register with the command dispatcher, and return responses to it --&gt;</span></div>
<div class="line">        &lt;<span class="keywordtype">port</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;cmdIn&quot;</span> <span class="keyword">data_type</span>=<span class="stringliteral">&quot;Fw::Cmd&quot;</span>  <span class="keyword">kind</span>=<span class="stringliteral">&quot;input&quot;</span> <span class="keyword">role</span>=<span class="stringliteral">&quot;Cmd&quot;</span>    <span class="keyword">max_number</span>=<span class="stringliteral">&quot;1&quot;</span>&gt;</div>
<div class="line">        &lt;/<span class="keywordtype">port</span>&gt;</div>
<div class="line">        &lt;<span class="keywordtype">port</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;cmdRegOut&quot;</span> <span class="keyword">data_type</span>=<span class="stringliteral">&quot;Fw::CmdReg&quot;</span> <span class="keyword">kind</span>=<span class="stringliteral">&quot;output&quot;</span> <span class="keyword">role</span>=<span class="stringliteral">&quot;CmdRegistration&quot;</span> <span class="keyword">max_number</span>=<span class="stringliteral">&quot;1&quot;</span>&gt;</div>
<div class="line">        &lt;/<span class="keywordtype">port</span>&gt;</div>
<div class="line">        &lt;<span class="keywordtype">port</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;cmdResponseOut&quot;</span> <span class="keyword">data_type</span>=<span class="stringliteral">&quot;Fw::CmdResponse&quot;</span> <span class="keyword">kind</span>=<span class="stringliteral">&quot;output&quot;</span> <span class="keyword">role</span>=<span class="stringliteral">&quot;CmdResponse&quot;</span> <span class="keyword">max_number</span>=<span class="stringliteral">&quot;1&quot;</span>&gt;</div>
<div class="line">        &lt;/<span class="keywordtype">port</span>&gt;</div>
<div class="line">        <span class="comment">&lt;!-- Event ports: send events, and text formated events --&gt;</span></div>
<div class="line">        &lt;<span class="keywordtype">port</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;eventOut&quot;</span> <span class="keyword">data_type</span>=<span class="stringliteral">&quot;Fw::Log&quot;</span>  <span class="keyword">kind</span>=<span class="stringliteral">&quot;output&quot;</span> <span class="keyword">role</span>=<span class="stringliteral">&quot;LogEvent&quot;</span>  <span class="keyword">max_number</span>=<span class="stringliteral">&quot;1&quot;</span>&gt;</div>
<div class="line">        &lt;/<span class="keywordtype">port</span>&gt;</div>
<div class="line">        &lt;<span class="keywordtype">port</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;textEventOut&quot;</span> <span class="keyword">data_type</span>=<span class="stringliteral">&quot;Fw::LogText&quot;</span> <span class="keyword">kind</span>=<span class="stringliteral">&quot;output&quot;</span> <span class="keyword">role</span>=<span class="stringliteral">&quot;LogTextEvent&quot;</span> <span class="keyword">max_number</span>=<span class="stringliteral">&quot;1&quot;</span>&gt;</div>
<div class="line">        &lt;/<span class="keywordtype">port</span>&gt;</div>
<div class="line">        <span class="comment">&lt;!-- Telemetry ports --&gt;</span></div>
<div class="line">        &lt;<span class="keywordtype">port</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;tlmOut&quot;</span> <span class="keyword">data_type</span>=<span class="stringliteral">&quot;Fw::Tlm&quot;</span>  <span class="keyword">kind</span>=<span class="stringliteral">&quot;output&quot;</span> <span class="keyword">role</span>=<span class="stringliteral">&quot;Telemetry&quot;</span> <span class="keyword">max_number</span>=<span class="stringliteral">&quot;1&quot;</span>&gt;</div>
<div class="line">        &lt;/<span class="keywordtype">port</span>&gt;</div>
<div class="line">        <span class="comment">&lt;!-- Serial ports: one to receive serial data, and one to provide buffers for the serial driver to use --&gt;</span></div>
<div class="line">        &lt;<span class="keywordtype">port</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;serialRecv&quot;</span> <span class="keyword">data_type</span>=<span class="stringliteral">&quot;Drv::SerialRead&quot;</span>  <span class="keyword">kind</span>=<span class="stringliteral">&quot;async_input&quot;</span> <span class="keyword">max_number</span>=<span class="stringliteral">&quot;1&quot;</span>&gt;</div>
<div class="line">        &lt;/<span class="keywordtype">port</span>&gt;</div>
<div class="line">        &lt;<span class="keywordtype">port</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;serialBufferOut&quot;</span> <span class="keyword">data_type</span>=<span class="stringliteral">&quot;Fw::BufferSend&quot;</span>  <span class="keyword">kind</span>=<span class="stringliteral">&quot;output&quot;</span>  <span class="keyword">max_number</span>=<span class="stringliteral">&quot;1&quot;</span>&gt;</div>
<div class="line">        &lt;/<span class="keywordtype">port</span>&gt;</div>
<div class="line">    &lt;/<span class="keywordtype">ports</span>&gt;</div>
<div class="line">&lt;/<span class="keywordtype">component</span>&gt;</div>
</div><!-- fragment --><p>This file first imports all *Ai.xml files needed for each port type, imports our command, telemetry channel, and event definition XMLs, and then defines all ports as we saw described above. There are several things to note:</p>
<ol type="1">
<li>The GPS component is an <em>active</em> component, which has a thread of its own to execute on. This was chosen as the GPS component has no realtime deadlines and is expected to run in parallel with other components in the system.</li>
<li><em>async_input</em> is used for the input port from the serial driver. The handler should be run on the <em>active</em> component's thread opposed to the invoking component's thread.</li>
</ol>
<p><em>active</em> components with <em>async_input</em> ports are a fairly common initial design for components. They are typically used unless the system has no thread scheduler, there are firm realtime deadlines, or other off-nominal requirements must be met. Port and component types are described in more detail in the aforementioned User Guide.</p>
<p>Instantiating the GPS component, and connecting it with other components in the system is done at the system level, enabling the individual components to be reused in different applications. We will see this step later, after we design our Commands, Events and Telemetry. We will also implement the C++ code as well.</p>
<h2><a class="anchor" id="autotoc_md46"></a>
Creating Commands.xml, Events.xml and Telemetry.xml Dictionaries</h2>
<p>These three XML dictionaries define the structure of commands, events, and telemetry that our component uses. This will allow the autocoder to automatically generate the needed code to process commands, and emit events and telemetry. This allows the developer to concentrate on the specific code for the component as opposed to hand coding the structure of these entities.</p>
<p>First we will create a command dictionary. The purpose of our command is to report the lock status of the GPS unit. This command will trigger code to emit an event, which will report if the GPS has "locked" status or not. <code>Commands.xml</code> in the <code>Gps</code> subdirectory should look like the following: </p><div class="fragment"><div class="line">&lt;?<span class="keyword">xml</span> <span class="keyword">version</span>=<span class="stringliteral">&quot;1.0&quot;</span> <span class="keyword">encoding</span>=<span class="stringliteral">&quot;UTF-8&quot;</span>?&gt;</div>
<div class="line">&lt;?<span class="keyword">oxygen</span> <span class="keyword">RNGSchema</span>=<span class="stringliteral">&quot;file:../xml/ISF_Component_Schema.rnc&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;compact&quot;</span>?&gt;</div>
<div class="line"><span class="comment">&lt;!-- GPS Tutorial: GpsApp/Gps/Commands.xml</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">This defines a single command to report the lock status of the GPS. This demonstrates a simple command that is useful</span></div>
<div class="line"><span class="comment">when working with GPS to determine if the data should be trusted.</span></div>
<div class="line"><span class="comment">--&gt;</span></div>
<div class="line">&lt;<span class="keywordtype">commands</span>&gt;</div>
<div class="line">    <span class="comment">&lt;!-- Define a single command that runs asynchronously on the component&#39;s own thread. The opcode &quot;0&quot; is relative to</span></div>
<div class="line"><span class="comment">    the GPS component&#39;s command space.  The mnemonic is the string a user will use to refer to this command. --&gt;</span></div>
<div class="line">    &lt;<span class="keywordtype">command</span> <span class="keyword">kind</span>=<span class="stringliteral">&quot;async&quot;</span> <span class="keyword">opcode</span>=<span class="stringliteral">&quot;0&quot;</span> <span class="keyword">mnemonic</span>=<span class="stringliteral">&quot;Gps_ReportLockStatus&quot;</span> &gt;</div>
<div class="line">        &lt;<span class="keywordtype">comment</span>&gt;<span class="keyword">A</span> <span class="keyword">command</span> <span class="keyword">to</span> <span class="keyword">force</span> <span class="keyword">an</span> <span class="keyword">EVR</span> <span class="keyword">reporting</span> <span class="keyword">lock</span> <span class="keyword">status.</span>&lt;/<span class="keywordtype">comment</span>&gt;</div>
<div class="line">    &lt;/<span class="keywordtype">command</span>&gt;</div>
<div class="line">&lt;/<span class="keywordtype">commands</span>&gt;</div>
</div><!-- fragment --><p>There are several notes to consider:</p>
<ol type="1">
<li>We use an <em>async*s command for the same reason as we use *async_input</em> ports above.</li>
<li>Each component defines it's own set of opcodes indexed from 0. The autocoder will prevent collisions between components by adding a prefix to the component's final opcode.</li>
<li>Users typically refer to the component's mnemonic and the opcode is typically internal to the F´ system.</li>
</ol>
<p>Next we will create an Events.xml dictionary that setup the events our component can emit. In this case we have two events, GPS locked and GPS lock lost. The <code>Events.xml</code> file in the <code>Gps</code> subdirectory should look like:</p>
<div class="fragment"><div class="line">&lt;?<span class="keyword">xml</span> <span class="keyword">version</span>=<span class="stringliteral">&quot;1.0&quot;</span> <span class="keyword">encoding</span>=<span class="stringliteral">&quot;UTF-8&quot;</span>?&gt;</div>
<div class="line">&lt;?<span class="keyword">oxygen</span> <span class="keyword">RNGSchema</span>=<span class="stringliteral">&quot;file:../xml/ISF_Component_Schema.rnc&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;compact&quot;</span>?&gt;</div>
<div class="line"><span class="comment">&lt;!-- GPS Tutorial: GpsApp/Gps/Events.xml</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">This defines two events, one at activity hi level to report that lock has been acquired, and one at warning hi level to</span></div>
<div class="line"><span class="comment">indicate lock lost.</span></div>
<div class="line"><span class="comment">--&gt;</span></div>
<div class="line">&lt;<span class="keywordtype">events</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">event</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;0&quot;</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;Gps_LockAquired&quot;</span> <span class="keyword">severity</span>=<span class="stringliteral">&quot;ACTIVITY_HI&quot;</span> <span class="keyword">format_string</span>=<span class="stringliteral">&quot;GPS lock acquired&quot;</span>&gt;</div>
<div class="line">        &lt;<span class="keywordtype">comment</span>&gt;<span class="keyword">A</span> <span class="keyword">notification</span> <span class="keyword">on</span> <span class="keyword">GPS</span> <span class="keyword">lock</span> <span class="keyword">acquired</span>&lt;/<span class="keywordtype">comment</span>&gt;</div>
<div class="line">    &lt;/<span class="keywordtype">event</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">event</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;Gps_LockLost&quot;</span> <span class="keyword">severity</span>=<span class="stringliteral">&quot;WARNING_HI&quot;</span> <span class="keyword">format_string</span>=<span class="stringliteral">&quot;GPS lock lost&quot;</span>&gt;</div>
<div class="line">        &lt;<span class="keywordtype">comment</span>&gt;<span class="keyword">A</span> <span class="keyword">warning</span> <span class="keyword">on</span> <span class="keyword">GPS</span> <span class="keyword">lock</span> <span class="keyword">lost</span>&lt;/<span class="keywordtype">comment</span>&gt;</div>
<div class="line">    &lt;/<span class="keywordtype">event</span>&gt;</div>
<div class="line">&lt;/<span class="keywordtype">events</span>&gt;</div>
</div><!-- fragment --><p>Here it should be noted that:</p><ol type="1">
<li>*id*s are indexed per-component, like opcodes</li>
<li>Typically users refer to names of telemetry channels</li>
<li>Format strings are not downlinked, but stored for display purposes</li>
</ol>
<p>Finally, we should create a Telemetry.xml dictionary. It will specify that we will downlink GPS latitude, GPS longitude, GPS altitude, GPS time, and current number of satellites visible to the GPS unit. These are all standard fields emitted GPS units and are the heart of our application. Our <code>Telemetry.xml</code> file in the <code>Gps</code> subdirectory should look like:</p>
<div class="fragment"><div class="line">&lt;?<span class="keyword">xml</span> <span class="keyword">version</span>=<span class="stringliteral">&quot;1.0&quot;</span> <span class="keyword">encoding</span>=<span class="stringliteral">&quot;UTF-8&quot;</span>?&gt;</div>
<div class="line">&lt;?<span class="keyword">oxygen</span> <span class="keyword">RNGSchema</span>=<span class="stringliteral">&quot;file:../xml/ISF_Component_Schema.rnc&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;compact&quot;</span>?&gt;</div>
<div class="line"><span class="comment">&lt;!-- GPS Tutorial: GpsApp/Gps/Telemetry.xml</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">This defines four telemetry channels to report basic GPS information.</span></div>
<div class="line"><span class="comment">--&gt;</span></div>
<div class="line">&lt;<span class="keywordtype">telemetry</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">channel</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;0&quot;</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;Gps_Latitude&quot;</span> <span class="keyword">data_type</span>=<span class="stringliteral">&quot;F32&quot;</span> <span class="keyword">abbrev</span>=<span class="stringliteral">&quot;GPS-0000&quot;</span>&gt;</div>
<div class="line">        &lt;<span class="keywordtype">comment</span>&gt;<span class="keyword">The</span> <span class="keyword">current</span> <span class="keyword">latitude</span>&lt;/<span class="keywordtype">comment</span>&gt;</div>
<div class="line">    &lt;/<span class="keywordtype">channel</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">channel</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;Gps_Longitude&quot;</span> <span class="keyword">data_type</span>=<span class="stringliteral">&quot;F32&quot;</span> <span class="keyword">abbrev</span>=<span class="stringliteral">&quot;GPS-0001&quot;</span>&gt;</div>
<div class="line">        &lt;<span class="keywordtype">comment</span>&gt;<span class="keyword">The</span> <span class="keyword">current</span> <span class="keyword">longitude</span>&lt;/<span class="keywordtype">comment</span>&gt;</div>
<div class="line">    &lt;/<span class="keywordtype">channel</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">channel</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;2&quot;</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;Gps_Altitude&quot;</span> <span class="keyword">data_type</span>=<span class="stringliteral">&quot;F32&quot;</span> <span class="keyword">abbrev</span>=<span class="stringliteral">&quot;GPS-0002&quot;</span>&gt;</div>
<div class="line">        &lt;<span class="keywordtype">comment</span>&gt;<span class="keyword">The</span> <span class="keyword">current</span> <span class="keyword">altitude</span>&lt;/<span class="keywordtype">comment</span>&gt;</div>
<div class="line">    &lt;/<span class="keywordtype">channel</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">channel</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;3&quot;</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;Gps_Count&quot;</span> <span class="keyword">data_type</span>=<span class="stringliteral">&quot;U32&quot;</span> <span class="keyword">abbrev</span>=<span class="stringliteral">&quot;GPS-0003&quot;</span>&gt;</div>
<div class="line">        &lt;<span class="keywordtype">comment</span>&gt;<span class="keyword">The</span> <span class="keyword">current</span> <span class="keyword">number</span> <span class="keyword">of</span> <span class="keyword">satilites</span>&lt;/<span class="keywordtype">comment</span>&gt;</div>
<div class="line">    &lt;/<span class="keywordtype">channel</span>&gt;</div>
<div class="line">&lt;/<span class="keywordtype">telemetry</span>&gt;</div>
</div><!-- fragment --><p>Some notes:</p><ol type="1">
<li>*id*s are indexed per-component, like opcodes, and event ids</li>
<li>Typically users refer to names of telemetry channels, but a shorthand for display is the abbrev</li>
<li>Telemetry channels can be primitive types and serializable. All of the GPS data could be reimplemented as a single serializable channel.</li>
</ol>
<p>At this stage, the design of the Gps component has been completed. Before we can implement code, we need to integrate the GPS component with the build system. This will be described next.</p>
<h1><a class="anchor" id="autotoc_md47"></a>
Setting Up the Build System for Gps and GpsApp</h1>
<p>Now it is time to create <em>CMakeList.txt</em> files for the GPS component, and GpsApp deployment. This will allow us to run our GPS component through the autocoder, and receive implementation templates in order to save time/effort.</p>
<p>First, in the <code>Gps</code> directory, create a module specific <em>CMakeLists.txt</em> file. Since we have not created any C++ files, our <em>CMakeLists.txt</em> will only contain the Ai.xml file we created. We'll add C++ files once we have created them.</p>
<p>The <code>CMakeLists.txt</code> created in the <code>Gps</code> directory should look like this: </p><div class="fragment"><div class="line">####</div>
<div class="line"># GPS Tutorial: GpsApp/Gps/CMakeLists.txt</div>
<div class="line">#</div>
<div class="line"># SOURCE_FILES: combined list of source and autocoding files</div>
<div class="line"># MOD_DEPS: (optional) module dependencies</div>
<div class="line">#</div>
<div class="line"># This file will setup the build for the Gps component. This is done by defining the SOURCE_FILES variable and then</div>
<div class="line"># registering the component as an F prime module. This allows autocoding and more!</div>
<div class="line">####</div>
<div class="line">set(SOURCE_FILES</div>
<div class="line">    &quot;${CMAKE_CURRENT_LIST_DIR}/GpsComponentAi.xml&quot;</div>
<div class="line">)</div>
<div class="line">register_fprime_module()</div>
</div><!-- fragment --><p>All the user has to do for components, and ports is to specify a list of source files (including autocoder inputs) and call <code>register_fprime_module()</code>. Next we will create an F´ deployment makefile. This links in the full F´ build system and defines our deployment. This is needed to be able to build our Gps module. We do not yet need a full system design (Topology), so we can perform this step now and build the Topology later.</p>
<p>First change to the <code>GpsApp</code> we created earlier. It should be the parent of the <code>Gps</code> subdirectory we are currently in.</p>
<div class="fragment"><div class="line">cd ..</div>
</div><!-- fragment --><p>Now we will create the <code>CMakeLists.txt</code> file here with the following content: </p><div class="fragment"><div class="line">####</div>
<div class="line"># GPS Tutorial &#39;GpsApp&#39; Deployment CMakeLists.txt: GpsApp/CMakeLists.txt</div>
<div class="line">#</div>
<div class="line"># This sets up the build for the &#39;GpsApp&#39; Application, including the custom</div>
<div class="line"># components. In addition, it imports FPrime.cmake, which includes the core F Prime</div>
<div class="line"># components.</div>
<div class="line">#</div>
<div class="line"># This file has several sections.</div>
<div class="line">#</div>
<div class="line"># 1. Header Section: define basic properties of the build</div>
<div class="line"># 2. F prime core: includes all F prime core components, and build-system properties</div>
<div class="line"># 3. Local subdirectories: contains all deployment specific directory additions</div>
<div class="line">####</div>
<div class="line"> </div>
<div class="line">##</div>
<div class="line"># Section 1: Basic Project Setup</div>
<div class="line">#</div>
<div class="line"># This contains the basic project information. Specifically, a cmake version and project definition. It also defines our</div>
<div class="line"># default paths to the F prime framework, and sets a default toolchain.</div>
<div class="line">##</div>
<div class="line">project(GpsApp C CXX)  # Should match the directory it is in</div>
<div class="line">cmake_minimum_required(VERSION 3.5)</div>
<div class="line">set(FPRIME_FRAMEWORK_PATH &quot;${CMAKE_CURRENT_LIST_DIR}/..&quot; CACHE PATH &quot;Location of F prime framework&quot; FORCE)</div>
<div class="line">set(FPRIME_PROJECT_ROOT &quot;${CMAKE_CURRENT_LIST_DIR}/..&quot; CACHE PATH &quot;Root path of F prime project&quot; FORCE)</div>
<div class="line"> </div>
<div class="line">##</div>
<div class="line"># Section 2: F prime Core</div>
<div class="line">#</div>
<div class="line"># This includes all of the F prime core components, and imports the make-system. F prime core</div>
<div class="line"># components will be placed in the F-Prime binary subdirectory to keep them from</div>
<div class="line"># colliding with deployment specific items.</div>
<div class="line">##</div>
<div class="line">include(&quot;${CMAKE_CURRENT_LIST_DIR}/../cmake/FPrime.cmake&quot;)</div>
<div class="line"># NOTE: register custom targets between these two lines</div>
<div class="line">include(&quot;${CMAKE_CURRENT_LIST_DIR}/../cmake/FPrime-Code.cmake&quot;)</div>
<div class="line"># Note: when building a deployment outside of the F prime core directories, then the</div>
<div class="line"># build root must be re-mapped for use with the standard build system components.</div>
<div class="line">#</div>
<div class="line"># In this way, the module names can be predicted as an offset from the (new) build</div>
<div class="line"># root, without breaking the standard locations of F prime.</div>
<div class="line">#</div>
<div class="line"># Uncomment the following lines, and set them to the BUILD_ROOT of your deployment,</div>
<div class="line"># which is typically one directory up from the CMakeLists.txt in the deployment dir.</div>
<div class="line">#set(FPRIME_CURRENT_BUILD_ROOT &quot;${CMAKE_CURRENT_LIST_DIR}/..&quot;)</div>
<div class="line">#message(STATUS &quot;F prime BUILD_ROOT currently set to: ${FPRIME_CURRENT_BUILD_ROOT}&quot;)</div>
<div class="line"> </div>
<div class="line">##</div>
<div class="line"># Section 3: Components and Topology</div>
<div class="line">#</div>
<div class="line"># This section includes deployment specific directories. This allows use of non- core components in the topology,</div>
<div class="line"># which is also added here.</div>
<div class="line">##</div>
<div class="line"># Add component subdirectories</div>
<div class="line">add_fprime_subdirectory(&quot;${CMAKE_CURRENT_LIST_DIR}/Gps/&quot;)</div>
</div><!-- fragment --><p>Most of this file is boilerplate code and is commented to provide guidance. There are still several things to be aware of:</p>
<ol type="1">
<li><code>project(GpsApp C CXX)</code> sets up our project. The name "GpsApp" should be the same as our chose directory.</li>
<li><code>include("${CMAKE_CURRENT_LIST_DIR}/../cmake/FPrime.cmake")</code> includes all the CMake based build utilities for F´.</li>
<li><code>include("${CMAKE_CURRENT_LIST_DIR}/../cmake/FPrime-Code.cmake")</code> includes all the F´ core code.</li>
<li><code>add_fprime_subdirectory("${CMAKE_CURRENT_LIST_DIR}/Gps/")</code> adds in our custom component as it isn't F´ core code.</li>
</ol>
<p>Next, the user may generate an F´ build in order to begin implementing and coding our module. This can be done with the following commands run from the <code>GpsApp</code> directory: </p><div class="fragment"><div class="line">fprime-util generate</div>
</div><!-- fragment --><p>This command should pass and we can then begin coding our module. If the command is not found, ensure that F´ has been installed correctly, and, if using a virtual environment for Python, ensure this environment has been activated.</p>
<p>If the command reports errors, ensure the files match those above (or borrow the sample code from this Tutorial's directory) and try again.</p>
<h1><a class="anchor" id="autotoc_md48"></a>
Coding Our Module</h1>
<p>Now it is time to code our module to read the GPS module and downlink the GPS telemetry. This is where the framework will help us considerably. All these previous steps set us up to use the autocoding features of F´. We can generate the basic implementation of the code by using the <code>fprime-util</code> <em>impl</em> command, which generates needed <em>GpsComponentImpl.cpp-tmpl</em> and <em>GpsComponentImpl.hpp-tmpl</em> files. We can use these as the basis for our implementation. In addition, the framework will also generate * <em>Ac.?pp</em> files, which handle the work of connecting ports allowing us to write minimal code to support the component interface. First we generate code templates, and move them into place. Since we don't already have implementations we can safely rename the template files without first checking for existing files.</p>
<p>Change back to the <code>Gps</code> subdirectory and generate implementations with: </p><div class="fragment"><div class="line">cd Gps</div>
<div class="line">fprime-util impl</div>
<div class="line">mv GpsComponentImpl.cpp-template GpsComponentImpl.cpp</div>
<div class="line">mv GpsComponentImpl.hpp-template GpsComponentImpl.hpp</div>
</div><!-- fragment --><p><em>Note:</em> If the developer regenerates the templates, care must be taken to not overwrite already implemented code by copying the templates to the implementation files.</p>
<p>At this point, the user may open up the <code>GpsComponentImpl.cpp</code> file and the <code>GpsComponentImpl.hpp</code> file in order to see what has been generated. The critical sections for our implementation are in <code>GpsComponentImpl.cpp</code> and are shown below: </p><div class="fragment"><div class="line">51   <span class="comment">// ----------------------------------------------------------------------</span></div>
<div class="line">52   <span class="comment">// Handler implementations for user-defined typed input ports</span></div>
<div class="line">53   <span class="comment">// ----------------------------------------------------------------------</span></div>
<div class="line">54 </div>
<div class="line">55   <span class="keywordtype">void</span> GpsComponentImpl ::</div>
<div class="line">56     serialRecv_handler(</div>
<div class="line">57         <span class="keyword">const</span> <a class="code" href="basic_types_8hpp.html#ae2c29dc7dc30247eb4144d3d058d1852">NATIVE_INT_TYPE</a> portNum,</div>
<div class="line">58         <a class="code" href="class_fw_1_1_buffer.html">Fw::Buffer</a> &amp;serBuffer,</div>
<div class="line">59         Drv::SerialReadStatus &amp;status</div>
<div class="line">60     )</div>
<div class="line">61   {</div>
<div class="line">62     <span class="comment">// TODO</span></div>
<div class="line">63   }</div>
<div class="line">64 </div>
<div class="line">65   <span class="comment">// ----------------------------------------------------------------------</span></div>
<div class="line">66   <span class="comment">// Command handler implementations</span></div>
<div class="line">67   <span class="comment">// ----------------------------------------------------------------------</span></div>
<div class="line">68 </div>
<div class="line">69   <span class="keywordtype">void</span> GpsComponentImpl ::</div>
<div class="line">70     Gps_ReportLockStatus_cmdHandler(</div>
<div class="line">71         <span class="keyword">const</span> <a class="code" href="fp_config_8hpp.html#a32d34ba1548079db6e25c3d0b1b386f0">FwOpcodeType</a> opCode,</div>
<div class="line">72         <span class="keyword">const</span> U32 cmdSeq</div>
<div class="line">73     )</div>
<div class="line">74   {</div>
<div class="line">75     <span class="comment">// TODO</span></div>
<div class="line">76     this-&gt;cmdResponse_out(opCode,cmdSeq,Fw::COMMAND_OK);</div>
<div class="line">77   }</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md49"></a>
Implementation</h2>
<p>In the generated implementations, we can seen that we have two actions "TODO". First we will need to implement a function called <em>serialRecv_handler</em> and the second is to implement a command handler for <em>Gps_ReportLockStatus_cmdHandler</em>. The other functions of our code are provided as functions we can use when we implement these two pieces. Those available functions are described below:</p>
<ol type="1">
<li>log_ACTIVITY_HI_Gps_LockAquired: used to emit the event <em>Gps_Lock_aquired</em> as defined in Events.xml</li>
<li>log_WARNING_HI_Gps_LockLost: used to emit the event <em>Gps_LockLost</em> as defined in Events.xml</li>
<li>tlmWrite_Gps_Latitude: used to send down <em>Latitude</em> telemetry as defined in Telemetry.xml</li>
<li>tlmWrite_Gps_Longitude: used to send down <em>Longitude</em> telemetry as defined in Telemetry.xml</li>
<li>tlmWrite_Gps_Altitude: used to send down <em>Altitude</em> telemetry as defined in Telemetry.xml</li>
<li>tlmWrite_Gps_Count: used to send down <em>Count</em> telemetry as defined in Telemetry.xml</li>
<li>sendCommandResponse: used to respond to a sent command. Call this in the above cmdHandler.</li>
</ol>
<p>In order to make a GPS processor that works well, we need to take the following steps:</p>
<p>0. Create a preamble function and send some buffers for the serial driver to use</p><ol type="1">
<li>Implement the serialRecv_handler function (called by the serial driver with one of the above buffers)</li>
<li>Break down the GPS message</li>
<li>Return the buffer to the serial driver</li>
<li>Downlink telemetry in serialRecv_handler</li>
<li>If lock is newly found, downlink a <em>LockAcquired</em> EVR</li>
<li>If lock is newly lost, downlink a <em>LockLost</em> EVR</li>
<li>Downlink a <em>LockAcquired</em> EVR in commandHandler, if lock is currently held</li>
<li>Downlink a <em>LockLost</em> EVR in commandHandler, if lock is not currently held</li>
<li>Respond to the commandHandler with a sendCommandResponse call</li>
</ol>
<p>These steps are called out in the following implementations of these two files. Since the purpose of this tutorial is not to demonstrate how to write each line of code, the steps above are called out in comments in the code.</p>
<h2><a class="anchor" id="autotoc_md50"></a>
GpsApp/Gps/GpsComponentImpl.cpp (Sample)</h2>
<div class="fragment"><div class="line"><span class="comment">// ======================================================================</span></div>
<div class="line"><span class="comment">// \title  GpsComponentImpl.cpp</span></div>
<div class="line"><span class="comment">// \author lestarch</span></div>
<div class="line"><span class="comment">// \brief  cpp implementation of the F&#39; sample GPS receiver for a</span></div>
<div class="line"><span class="comment">//         NMEA GPS receiver device.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// \copyright</span></div>
<div class="line"><span class="comment">// Copyright 2018, lestarch.</span></div>
<div class="line"><span class="comment">// ======================================================================</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;GpsApp/Gps/GpsComponentImpl.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="basic_types_8hpp.html">Fw/Types/BasicTypes.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="logger_8hpp.html">Fw/Logger/Logger.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;cstring&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>GpsApp {</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// ----------------------------------------------------------------------</span></div>
<div class="line">  <span class="comment">// Construction, initialization, and destruction</span></div>
<div class="line">  <span class="comment">// ----------------------------------------------------------------------</span></div>
<div class="line"> </div>
<div class="line">  GpsComponentImpl ::</div>
<div class="line"><span class="preprocessor">#if FW_OBJECT_NAMES == 1</span></div>
<div class="line">    GpsComponentImpl(</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">const</span> compName</div>
<div class="line">    ) :</div>
<div class="line">      GpsComponentBase(compName),</div>
<div class="line">#else</div>
<div class="line">      GpsComponentBase(void),</div>
<div class="line">#endif</div>
<div class="line">      <span class="comment">// Initialize the lock to &quot;false&quot;</span></div>
<div class="line">      m_locked(false)</div>
<div class="line">  {</div>
<div class="line"> </div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> GpsComponentImpl ::</div>
<div class="line">    init(</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="basic_types_8hpp.html#ae2c29dc7dc30247eb4144d3d058d1852">NATIVE_INT_TYPE</a> queueDepth,</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="basic_types_8hpp.html#ae2c29dc7dc30247eb4144d3d058d1852">NATIVE_INT_TYPE</a> instance</div>
<div class="line">    )</div>
<div class="line">  {</div>
<div class="line">    GpsComponentBase::init(queueDepth, instance);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//Step 0: The linux serial driver keeps its storage externally. This means that we need to supply it some buffers to</span></div>
<div class="line">  <span class="comment">//        work with. This code will loop through our member variables holding the buffers and send them to the linux</span></div>
<div class="line">  <span class="comment">//        serial driver.  &#39;preamble&#39; is automatically called after the system is constructed, before the system runs</span></div>
<div class="line">  <span class="comment">//        at steady-state. This allows for initialization code that invokes working ports.</span></div>
<div class="line">  <span class="keywordtype">void</span> GpsComponentImpl :: preamble(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">      <span class="keywordflow">for</span> (<a class="code" href="basic_types_8hpp.html#ae2c29dc7dc30247eb4144d3d058d1852">NATIVE_INT_TYPE</a> buffer = 0; buffer &lt; NUM_UART_BUFFERS; buffer++) {</div>
<div class="line">          <span class="comment">//Assign the raw data to the buffer. Make sure to include the side of the region assigned.</span></div>
<div class="line">          this-&gt;m_recvBuffers[buffer].setdata((<a class="code" href="sha_8h.html#ae5a6272795b1b8e0045aa7a4319dceb8">U64</a>)this-&gt;m_uartBuffers[buffer]);</div>
<div class="line">          this-&gt;m_recvBuffers[buffer].setsize(UART_READ_BUFF_SIZE);</div>
<div class="line">          <span class="comment">// Invoke the port to send the buffer out.</span></div>
<div class="line">          this-&gt;serialBufferOut_out(0, this-&gt;m_recvBuffers[buffer]);</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  GpsComponentImpl ::</div>
<div class="line">    ~GpsComponentImpl(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line"> </div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// ----------------------------------------------------------------------</span></div>
<div class="line">  <span class="comment">// Handler implementations for user-defined typed input ports</span></div>
<div class="line">  <span class="comment">// ----------------------------------------------------------------------</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Step 1: serialIn</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// By implementing this &quot;handler&quot; we can respond to the serial device sending us data buffers containing the GPS</span></div>
<div class="line">  <span class="comment">// data. This handles our serial messages. It should perform the actions we expect from the design phases.</span></div>
<div class="line">  <span class="keywordtype">void</span> GpsComponentImpl ::</div>
<div class="line">    serialRecv_handler(</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="basic_types_8hpp.html#ae2c29dc7dc30247eb4144d3d058d1852">NATIVE_INT_TYPE</a> portNum, </div>
<div class="line">        <a class="code" href="class_fw_1_1_buffer.html">Fw::Buffer</a> &amp;serBuffer, </div>
<div class="line">        Drv::SerialReadStatus &amp;serial_status </div>
<div class="line">    )</div>
<div class="line">  {</div>
<div class="line">      <span class="comment">// Local variable definitions</span></div>
<div class="line">      <span class="keywordtype">int</span> status = 0;</div>
<div class="line">      <span class="keywordtype">float</span> lat = 0.0f, lon = 0.0f;</div>
<div class="line">      GpsPacket packet;</div>
<div class="line">      <span class="comment">// Grab the size (used amount of the buffer) and a pointer to the data in the buffer</span></div>
<div class="line">      U32 buffsize = <span class="keyword">static_cast&lt;</span>U32<span class="keyword">&gt;</span>(serBuffer.getsize());</div>
<div class="line">      <span class="keywordtype">char</span>* pointer = <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(serBuffer.getdata());</div>
<div class="line">      <span class="comment">// Check for invalid read status, log an error, return buffer and abort if there is a problem</span></div>
<div class="line">      <span class="keywordflow">if</span> (serial_status != Drv::SER_OK) {</div>
<div class="line">          <a class="code" href="class_fw_1_1_logger.html#a0a68fd1aef48f608252dd3e84013035a">Fw::Logger::logMsg</a>(<span class="stringliteral">&quot;[WARNING] Received buffer with bad packet: %d\n&quot;</span>, serial_status);</div>
<div class="line">          <span class="comment">// We MUST return the buffer or the serial driver won&#39;t be able to reuse it. The same buffer send call is used</span></div>
<div class="line">          <span class="comment">// as we did in &quot;preamble&quot;.  Since the buffer&#39;s size was overwritten to hold the actual data size, we need to</span></div>
<div class="line">          <span class="comment">// reset it to the full data block size before returning it.</span></div>
<div class="line">          serBuffer.setsize(UART_READ_BUFF_SIZE);</div>
<div class="line">          this-&gt;serialBufferOut_out(0, serBuffer);</div>
<div class="line">          <span class="keywordflow">return</span>;</div>
<div class="line">      }</div>
<div class="line">      <span class="comment">// If not enough data is available for a full messsage, return the buffer and abort.</span></div>
<div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (buffsize &lt; 24) {</div>
<div class="line">          <span class="comment">// We MUST return the buffer or the serial driver won&#39;t be able to reuse it. The same buffer send call is used</span></div>
<div class="line">          <span class="comment">// as we did in &quot;preamble&quot;.  Since the buffer&#39;s size was overwritten to hold the actual data size, we need to</span></div>
<div class="line">          <span class="comment">// reset it to the full data block size before returning it.</span></div>
<div class="line">          serBuffer.setsize(UART_READ_BUFF_SIZE);</div>
<div class="line">          this-&gt;serialBufferOut_out(0, serBuffer);</div>
<div class="line">          <span class="keywordflow">return</span>;</div>
<div class="line">      }</div>
<div class="line">      <span class="comment">//Step 2:</span></div>
<div class="line">      <span class="comment">//  Parse the GPS message from the UART (looking for $GPGGA messages). This uses standard C functions to read all</span></div>
<div class="line">      <span class="comment">//  the defined protocol messages into our GPS package struct. If all 9 items are parsed, we break. Otherwise we</span></div>
<div class="line">      <span class="comment">//  continue to scan the block of data looking for messages further in.</span></div>
<div class="line">      <span class="keywordflow">for</span> (U32 i = 0; i &lt; (buffsize - 24); i++) {</div>
<div class="line">          status = sscanf(pointer, <span class="stringliteral">&quot;$GPGGA,%f,%f,%c,%f,%c,%u,%u,%f,%f&quot;</span>,</div>
<div class="line">              &amp;packet.utcTime, &amp;packet.dmNS, &amp;packet.northSouth,</div>
<div class="line">              &amp;packet.dmEW, &amp;packet.eastWest, &amp;packet.lock,</div>
<div class="line">              &amp;packet.count, &amp;packet.filler, &amp;packet.altitude);</div>
<div class="line">          <span class="comment">//Break when all GPS items are found</span></div>
<div class="line">          <span class="keywordflow">if</span> (status == 9) {</div>
<div class="line">              <span class="keywordflow">break</span>;</div>
<div class="line">          }</div>
<div class="line">          pointer = pointer + 1;</div>
<div class="line">      }</div>
<div class="line">      <span class="comment">//If we failed to find the GPGGA then return the buffer and abort.</span></div>
<div class="line">      <span class="keywordflow">if</span> (status == 0) {</div>
<div class="line">          <span class="comment">// We MUST return the buffer or the serial driver won&#39;t be able to reuse it. The same buffer send call is used</span></div>
<div class="line">          <span class="comment">// as we did in &quot;preamble&quot;.  Since the buffer&#39;s size was overwritten to hold the actual data size, we need to</span></div>
<div class="line">          <span class="comment">// reset it to the full data block size before returning it.</span></div>
<div class="line">          serBuffer.setsize(UART_READ_BUFF_SIZE);</div>
<div class="line">          this-&gt;serialBufferOut_out(0, serBuffer);</div>
<div class="line">          <span class="keywordflow">return</span>;</div>
<div class="line">      }</div>
<div class="line">      <span class="comment">// If we found some of the message but not all of the message, then log an error, return the buffer and exit.</span></div>
<div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (status != 9) {</div>
<div class="line">          <a class="code" href="class_fw_1_1_logger.html#a0a68fd1aef48f608252dd3e84013035a">Fw::Logger::logMsg</a>(<span class="stringliteral">&quot;[ERROR] GPS parsing failed: %d\n&quot;</span>, status);</div>
<div class="line">          <span class="comment">// We MUST return the buffer or the serial driver won&#39;t be able to reuse it. The same buffer send call is used</span></div>
<div class="line">          <span class="comment">// as we did in &quot;preamble&quot;.  Since the buffer&#39;s size was overwritten to hold the actual data size, we need to</span></div>
<div class="line">          <span class="comment">// reset it to the full data block size before returning it.</span></div>
<div class="line">          serBuffer.setsize(UART_READ_BUFF_SIZE);</div>
<div class="line">          this-&gt;serialBufferOut_out(0, serBuffer);</div>
<div class="line">          <span class="keywordflow">return</span>;</div>
<div class="line">      }</div>
<div class="line">      <span class="comment">//GPS packet locations are of the form: ddmm.mmmm</span></div>
<div class="line">      <span class="comment">//We will convert to lat/lon in degrees only before downlinking</span></div>
<div class="line">      <span class="comment">//Latitude degrees, add on minutes (converted to degrees), multiply by direction</span></div>
<div class="line">      lat = (U32)(packet.dmNS/100.0f);</div>
<div class="line">      lat = lat + (packet.dmNS - (lat * 100.0f))/60.0f;</div>
<div class="line">      lat = lat * ((packet.northSouth == <span class="charliteral">&#39;N&#39;</span>) ? 1 : -1);</div>
<div class="line">      <span class="comment">//Longitude degrees, add on minutes (converted to degrees), multiply by direction</span></div>
<div class="line">      lon = (U32)(packet.dmEW/100.0f);</div>
<div class="line">      lon = lon + (packet.dmEW - (lon * 100.0f))/60.f;</div>
<div class="line">      lon = lon * ((packet.eastWest == <span class="charliteral">&#39;E&#39;</span>) ? 1 : -1);</div>
<div class="line">      <span class="comment">//Step 4: call the downlink functions to send down data</span></div>
<div class="line">      tlmWrite_Gps_Latitude(lat);</div>
<div class="line">      tlmWrite_Gps_Longitude(lon);</div>
<div class="line">      tlmWrite_Gps_Altitude(packet.altitude);</div>
<div class="line">      tlmWrite_Gps_Count(packet.count);</div>
<div class="line">      <span class="comment">//Lock status update only if changed</span></div>
<div class="line">      <span class="comment">//Step 5,6: note changed lock status</span></div>
<div class="line">      <span class="comment">// Emit an event if the lock has been acquired, or lost</span></div>
<div class="line">      <span class="keywordflow">if</span> (packet.lock == 0 &amp;&amp; m_locked) {</div>
<div class="line">          m_locked = <span class="keyword">false</span>;</div>
<div class="line">          log_WARNING_HI_Gps_LockLost();</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (packet.lock == 1 &amp;&amp; !m_locked) {</div>
<div class="line">          m_locked = <span class="keyword">true</span>;</div>
<div class="line">          log_ACTIVITY_HI_Gps_LockAquired();</div>
<div class="line">      }</div>
<div class="line">      <span class="comment">// We MUST return the buffer or the serial driver won&#39;t be able to reuse it. The same buffer send call is used</span></div>
<div class="line">      <span class="comment">// as we did in &quot;preamble&quot;.  Since the buffer&#39;s size was overwritten to hold the actual data size, we need to</span></div>
<div class="line">      <span class="comment">// reset it to the full data block size before returning it.</span></div>
<div class="line">      serBuffer.setsize(UART_READ_BUFF_SIZE);</div>
<div class="line">      this-&gt;serialBufferOut_out(0, serBuffer);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// ----------------------------------------------------------------------</span></div>
<div class="line">  <span class="comment">// Command handler implementations</span></div>
<div class="line">  <span class="comment">// ----------------------------------------------------------------------</span></div>
<div class="line">  <span class="comment">//Step 7,8: respond to a command to report lock status.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// When a status command is received, respond by emitting the</span></div>
<div class="line">  <span class="comment">// current lock status as an Event.</span></div>
<div class="line">  <span class="keywordtype">void</span> GpsComponentImpl ::</div>
<div class="line">    Gps_ReportLockStatus_cmdHandler(</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="fp_config_8hpp.html#a32d34ba1548079db6e25c3d0b1b386f0">FwOpcodeType</a> opCode,</div>
<div class="line">        <span class="keyword">const</span> U32 cmdSeq</div>
<div class="line">    )</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">//Locked-force print</span></div>
<div class="line">    <span class="keywordflow">if</span> (m_locked) {</div>
<div class="line">        log_ACTIVITY_HI_Gps_LockAquired();</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        log_WARNING_HI_Gps_LockLost();</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">//Step 9: complete command</span></div>
<div class="line">    this-&gt;cmdResponse_out(opCode, cmdSeq, Fw::COMMAND_OK);</div>
<div class="line">  }</div>
<div class="line">} <span class="comment">// end namespace GpsApp</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md51"></a>
GpsApp/Gps/GpsComponentImpl.hpp (Sample)</h2>
<div class="fragment"><div class="line"><span class="comment">// ====================================================================== </span></div>
<div class="line"><span class="comment">// \title  GpsComponentImpl.hpp</span></div>
<div class="line"><span class="comment">// \author lemstarch</span></div>
<div class="line"><span class="comment">// \brief  hpp header file for the sample F&#39; GPS component, based on a</span></div>
<div class="line"><span class="comment">//         NMEA GPS receiver.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// \copyright</span></div>
<div class="line"><span class="comment">// Copyright 2018, lestarch</span></div>
<div class="line"><span class="comment">// ====================================================================== </span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifndef GpsComponentImpl_HPP</span></div>
<div class="line"><span class="preprocessor">#define GpsComponentImpl_HPP</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;GpsApp/Gps/GpsComponentAc.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Need to define the memory footprint of our buffers. This means defining a count of buffers, and how big each is. In</span></div>
<div class="line"><span class="comment">// this example, we will allow the Gps component to manage its own buffers.</span></div>
<div class="line"><span class="preprocessor">#define NUM_UART_BUFFERS 20</span></div>
<div class="line"><span class="preprocessor">#define UART_READ_BUFF_SIZE 1024</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>GpsApp {</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">class </span>GpsComponentImpl :</div>
<div class="line">    <span class="keyword">public</span> GpsComponentBase</div>
<div class="line">  {</div>
<div class="line">      <span class="keyword">struct </span>GpsPacket {</div>
<div class="line">          <span class="keywordtype">float</span> utcTime;</div>
<div class="line">          <span class="keywordtype">float</span> dmNS;</div>
<div class="line">          <span class="keywordtype">char</span> northSouth;</div>
<div class="line">          <span class="keywordtype">float</span> dmEW;</div>
<div class="line">          <span class="keywordtype">char</span> eastWest;</div>
<div class="line">          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lock;</div>
<div class="line">          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> count;</div>
<div class="line">          <span class="keywordtype">float</span> filler;</div>
<div class="line">          <span class="keywordtype">float</span> altitude;</div>
<div class="line">      };</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// ----------------------------------------------------------------------</span></div>
<div class="line">      <span class="comment">// Construction, initialization, and destruction</span></div>
<div class="line">      <span class="comment">// ----------------------------------------------------------------------</span></div>
<div class="line"> </div>
<div class="line">      GpsComponentImpl(</div>
<div class="line">#<span class="keywordflow">if</span> <a class="code" href="fp_config_8hpp.html#afea3a9ff2b434835add02a2188a3f358">FW_OBJECT_NAMES</a> == 1</div>
<div class="line">          <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">const</span> compName </div>
<div class="line">#<span class="keywordflow">else</span></div>
<div class="line">          <span class="keywordtype">void</span></div>
<div class="line">#endif</div>
<div class="line">      );</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">void</span> init(</div>
<div class="line">          <span class="keyword">const</span> <a class="code" href="basic_types_8hpp.html#ae2c29dc7dc30247eb4144d3d058d1852">NATIVE_INT_TYPE</a> queueDepth, </div>
<div class="line">          <span class="keyword">const</span> <a class="code" href="basic_types_8hpp.html#ae2c29dc7dc30247eb4144d3d058d1852">NATIVE_INT_TYPE</a> instance = 0 </div>
<div class="line">      );</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">void</span> preamble(<span class="keywordtype">void</span>);</div>
<div class="line"> </div>
<div class="line">      ~GpsComponentImpl(<span class="keywordtype">void</span>);</div>
<div class="line"> </div>
<div class="line">    PRIVATE:</div>
<div class="line">      <span class="comment">// ----------------------------------------------------------------------</span></div>
<div class="line">      <span class="comment">// Handler implementations for user-defined typed input ports</span></div>
<div class="line">      <span class="comment">// ----------------------------------------------------------------------</span></div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">void</span> serialRecv_handler(</div>
<div class="line">          <span class="keyword">const</span> <a class="code" href="basic_types_8hpp.html#ae2c29dc7dc30247eb4144d3d058d1852">NATIVE_INT_TYPE</a> portNum, </div>
<div class="line">          <a class="code" href="class_fw_1_1_buffer.html">Fw::Buffer</a> &amp;serBuffer, </div>
<div class="line">          Drv::SerialReadStatus &amp;serial_status </div>
<div class="line">      );</div>
<div class="line"> </div>
<div class="line">    PRIVATE:</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// ----------------------------------------------------------------------</span></div>
<div class="line">      <span class="comment">// Command handler implementations </span></div>
<div class="line">      <span class="comment">// ----------------------------------------------------------------------</span></div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">void</span> Gps_ReportLockStatus_cmdHandler(</div>
<div class="line">          <span class="keyword">const</span> <a class="code" href="fp_config_8hpp.html#a32d34ba1548079db6e25c3d0b1b386f0">FwOpcodeType</a> opCode, </div>
<div class="line">          <span class="keyword">const</span> U32 cmdSeq </div>
<div class="line">      );</div>
<div class="line">      <span class="keywordtype">bool</span> m_locked;</div>
<div class="line">      <a class="code" href="class_fw_1_1_buffer.html">Fw::Buffer</a> m_recvBuffers[NUM_UART_BUFFERS];</div>
<div class="line">      <a class="code" href="basic_types_8hpp.html#a5a6a98ce49e7a4580aad271214c422bc">BYTE</a> m_uartBuffers[NUM_UART_BUFFERS][UART_READ_BUFF_SIZE];</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end namespace GpsApp</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p>Next, we need to add (or uncomment) our .cpp and .hpp to the <code>CMakeLists.txt</code> in the <code>GpsApp/Gps</code> subdirectory. The final version will look like this:</p>
<h2><a class="anchor" id="autotoc_md52"></a>
GpsApp/Gps/CMakeListst.txt (final)</h2>
<div class="fragment"><div class="line">####</div>
<div class="line"># GPS Tutorial: GpsApp/Gps/CMakeLists.txt</div>
<div class="line">#</div>
<div class="line"># SOURCE_FILES: combined list of source and autocoding files</div>
<div class="line"># MOD_DEPS: (optional) module dependencies</div>
<div class="line">#</div>
<div class="line"># This file will setup the build for the Gps component. This is done by defining the SOURCE_FILES variable and then</div>
<div class="line"># registering the component as an F prime module. This allows autocoding and more!</div>
<div class="line">####</div>
<div class="line">set(SOURCE_FILES</div>
<div class="line">    &quot;${CMAKE_CURRENT_LIST_DIR}/GpsComponentAi.xml&quot;</div>
<div class="line">    &quot;${CMAKE_CURRENT_LIST_DIR}/GpsComponentImpl.cpp&quot;</div>
<div class="line">)</div>
<div class="line">register_fprime_module()</div>
</div><!-- fragment --><p>Finally, run the F´ utility to build this component using <code>fprime-util build</code>. This will regenerate the CMake build file, which we made with the <code>fprime-util generate</code> command earlier. This should pass and the code should be ready. We'll then integrate it into a new topology.</p>
<div class="fragment"><div class="line">fprime-util build</div>
</div><!-- fragment --><p>We are now ready to make a Topology for this application, and test it!</p>
<h1><a class="anchor" id="autotoc_md53"></a>
Topology</h1>
<p>We are finally ready to build our topology to connect the GPS module up to the standard F´ components. Then we can see if this design works by cross compiling and running it on the RPI. We'll be modifying the existing <code><a class="el" href="namespace_ref.html">Ref</a></code> topology in order more quickly create one of our own. A more useful system diagram is shown below.</p>
<p><img src="img/gps-top.png" alt="GPS App Topology Diagram" class="inline"/></p>
<p>There are many components that will come "for free" by copying the Reference application. However, the key components that represent our application's flow are shown in the diagram. We to make sure that all 8 of our ports for the Gps component have been hooked-up. This involves two major steps:</p>
<ol type="1">
<li>Instantiate <code>LinuxSerialDriver</code> and <code>Gps</code> components</li>
<li>Add new port connections to wire up the <code>Gps</code> and <code>LinuxSerialDriver</code></li>
</ol>
<p>We'll work through these steps below.</p>
<h2><a class="anchor" id="autotoc_md54"></a>
Clone the Ref Application</h2>
<p>First, the Reference application's topology is copied into the <em>Top</em> folder of <em>GpsApp</em> application and we'll grab. We do this as a convenience to save time during this tutorial. It is easier and faster to start with the Reference application's files and modify them to construct our topology.</p>
<p>From the <code>GpsApp</code> directory run the following: </p><div class="fragment"><div class="line">cp -r ../Ref/Top ./Top</div>
<div class="line">rm ./Top/RefTopologyAppDictionary.xml ./Top/RefTopologyAppAi_IDTableLog.txt ./Top/RefTopologyAppID.csv</div>
</div><!-- fragment --><p><b>Note:</b> do not worry if the removed files do not exist, the remove is there to clean-up files generated during a build.</p>
<h2><a class="anchor" id="autotoc_md55"></a>
Update the GpsApp CmakeLists.txt</h2>
<p>Now that we have a topology, we'll go ahead and update the <code>CMakeLists.txt</code> file in the <code>GpsApp</code> folder. This will nearly complete the modifications we need for this file. You may choose later to make the <code>raspberrypi</code> toolchain to be default once we start cross-compiling. We do this by adding a single line to include the <code>Top</code> directory at the very end of the file.</p>
<p>Make sure the <code>CMakeLists.txt</code> in the <code>GpsApp</code> directory has the following line added to the end: </p><div class="fragment"><div class="line">add_fprime_subdirectory(&quot;${CMAKE_CURRENT_LIST_DIR}/Top/&quot;)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md56"></a>
Build the Topology Sources</h2>
<p>A topology consists of several files that instantiate the components in C++, construct and initialize the system, and represent the "main function" or entry point into the code. These files are shown below:</p>
<ol type="1">
<li><b>GpsTopologyAppAi.xml</b>: the design file showing the list of components, and the connections between components. This file is based on RefTopologyAppAi.xml from the reference application with new ports added. GpsTopologyAppAi.xml should replace RefTopologyAppAi.xml.</li>
<li><b>Components.hpp</b>: the header file declaring in code the same components as listed in the topology ai XML, along with includes of the headers that define them.</li>
<li><b>Topology.cpp</b>: top level code and initialization of the components, threads, and registration of commands.</li>
<li><b>Main.cpp</b>: entry point to the code.</li>
</ol>
<p>Essentially, GpsTopologyAppAi.xml is the design, Components.hpp is the definitions, and Topology.cpp is the system initialization code. All of these files are referenced by the CMake files we inherited from the reference app. Building the distribution (fprime/GpsApp) will include the topology (GpsApp/Top) as its entry-point creating a single binary, which represents our software.</p>
<p>Sample versions of these files are provided below, and are annotated with comments representing the changes made to support the Gps Application. <b>Note:</b> these files are available in a working repository at: <a href="https://github.com/LeStarch/fprime/tree/gps-application">https://github.com/LeStarch/fprime/tree/gps-application</a> in case the user prefers a direct checkout of working code. The files are linked below:</p>
<ol type="1">
<li><a href="GpsApp/Top/GpsAppTopologyAppAi.xml">Top/GpsAppTopologyAi.xml</a></li>
<li><a href="GpsApp/Top/Components.hpp">Top/Components.hpp</a></li>
<li><a href="GpsApp/Top/Topology.cpp">Top/Topology.cpp</a></li>
<li><a href="GpsApp/Top/Main.cpp">Top/Main.cpp</a></li>
</ol>
<p>We will also need to update the <code>CMakeLists.txt</code> in the <code>Top</code> directory to change the name of "RefTopologyAppAi.xml" to "GpsTopologyAppAi.xml".</p>
<p>Once these files have been added to the <em>GpsApp/Top</em> folder, we have a complete project. The project can be built by changing directory to the deployment directory, issuing our build commands and then running the executable.</p>
<h1><a class="anchor" id="autotoc_md57"></a>
Running the Executable On the Native Host with the Ground System</h1>
<p>We'll start by removing the old build generation. By adding the top folder, this will remove any issues with the build. Then we can build, and run right on the local machine. If the user has a USB based GPS receiver, the code should work.</p>
<p>In the <code>GpsApp</code> directory, build and install the code. Install will automatically build if the code has not been built. </p><div class="fragment"><div class="line">cd GpsApp</div>
<div class="line">fprime-util purge</div>
<div class="line">fprime-util generate</div>
<div class="line">fprime-util install</div>
</div><!-- fragment --><p>Now run the ground system in one terminal and the Gps app in the other. Here we inform the ground system that we will run the application independently. </p><div class="fragment"><div class="line"># In GpsApp directory</div>
<div class="line">fprime-gds -d . -n</div>
</div><!-- fragment --><p>Run the application binary. <b>Note:</b> we are currently compiling for the native OS. Linux is assumed and so is the path to the USB GPS device. If the device doesn't exist, the system will run but log an error opening it.</p>
<div class="fragment"><div class="line">cd fprime/GpsApp</div>
<div class="line"># For &quot;Linux&quot;:</div>
<div class="line">./bin/Linux/GpsApp -a 127.0.0.1 -p 50000 -d /dev/ttyACM0</div>
<div class="line"># For &quot;Mac OSX&quot;:</div>
<div class="line">./bin/Darwin/GpsApp -a 127.0.0.1 -p 50000 -d /dev/ttyACM0</div>
</div><!-- fragment --><p>If you see output similar to the following, when running with the USB GPS you have successfully, completed the development of our tutorial. We'll discuss how to cross compile for the Raspberry PI and run on the Raspberry pi next.</p>
<p>Once the ground system loads in the user's browser, the user can start seeing what the software is doing. If it doesn't load, then the user should go navigate to: <a href="https://localhost:5000">https://localhost:5000</a>.</p>
<p>First click on the "Channels" tab at the top. The user should at least see the "rateGroup1Comp.RgMaxTime" channel. If the GPS is working and has lock, then the user should see the GPS channels as well. This is seen below. Later we will discuss what to do if this did not show up.</p>
<p><img src="img/gps-channels.png" alt="GPS GDS Channels Tab" class="inline"/></p>
<p>Next, the user should navigate to the "Commanding" tab and select "gpsImpl.Gps_ReportLockStatus" from the drop down. The user may start to type in the dropdown to subset the list. Press the green "Send" button and the command should be sent as seen below.</p>
<p><img src="img/gps-commands.png" alt="GPS GDS Commanding Tab" class="inline"/></p>
<p>Finally, the user can check the "Events" tab at the top to see the lock status as we asked it to be reported.</p>
<p><img src="img/gps-events.png" alt="GPS GDS Event Tab" class="inline"/></p>
<p>To exit the ground system, CTRL-C the terminal process.</p>
<p>If the above code did not work, the user should check the following:</p>
<ol type="1">
<li>Issue the <code>cmdDisp.CMD_NO_OP</code> command from the "Commanding" tab and check the "Events" tab. The user should expect to see NO_OP events, proving the executable is working and the data flow is working. If this does not work, then rerun the ground system and binary. Ensure no errors have been reported. Check the "Logs" tab for logs in the system and ensure there are no errors there. Make sure port 50000 is free, and that no other ground systems are running.</li>
<li>Assuming the user has working <code>cmdDisp.CMD_NO_OP</code>, the code is running. Thus the users should rerun the "gpsImpl.Gps_ReportLockStatus" command. If the lock status is not acquired, then the user will not see GPS channels. Sometimes the ground connection is not fast enough to see the startup events and channels, so the ground system is blank until an event happens, like the one from <code>cmdDisp.CMD_NO_OP</code>.</li>
</ol>
<p>Again, ensure the ground system and running binary have been stopped with the CTRL-C to kill the process.</p>
<h1><a class="anchor" id="autotoc_md58"></a>
Cross Compiling for the Raspberry PI</h1>
<p>Once we have the code building for Linux, it is time to engage the raspberry pi cross compilation tools in order to build a binary that will run on the Raspberry PI. We'll be working with code for the Raspberry PI 3, but it should work on the RPI 2 as well.</p>
<h2><a class="anchor" id="autotoc_md59"></a>
Cross Compiling Explicitly</h2>
<p>The first step is to follow the installation of the tools for the RPI cross compile as documented here: ../../../RPI/README.md "RPI Deployment README.md".</p>
<p>In order to cross-compile for the a specific architecture, the user needs to generate a new build directory using a toolchain file for that architecture. F´ includes a toolchain for the raspberry PI, assuming the tools are installed in the manner described in the above readme. This toolchain is called "raspberrypi". The build can be generated by running the following commands in the <code>GpsApp</code> directory:</p>
<div class="fragment"><div class="line">fprime-util generate raspberrypi</div>
<div class="line">fprime-util install raspberrypi</div>
</div><!-- fragment --><p>This will generate the binary at <code>GpsApp/bin/arm-linux-gnueabihf/GpsApp</code>. The user then may run the ground system as before. Ensure that the system and network firewall allow through port 50000 from the PI to the host, and then run:</p>
<div class="fragment"><div class="line">fprime-gds -d . -n</div>
</div><!-- fragment --><p>Assuming there is no firewall or other network limits between the PI and the host, the user can run the following from a separate terminal run the following:</p>
<div class="fragment"><div class="line">cd fprime/GpsApp</div>
<div class="line">scp bin/arm-linux-gnueabihf/GpsApp pi@&lt;raspberry pi IP&gt;</div>
<div class="line">ssh pi@&lt;raspberry pi IP&gt;</div>
<div class="line">./GpsApp -a &lt;ground system IP&gt; -p 50000 -d &lt;serial port, /dev/ttyACM0 for USB&gt;</div>
</div><!-- fragment --><p>Now the PI should be powered up and running the embedded Linux binary, and our host system should be running the ground system. If the code work when running natively, and isn't connecting for this example the cause it likely a firewall issue. Again make sure port 50000 is exposed to the PI, and that the pi can ping the ground system machine.</p>
<h2><a class="anchor" id="autotoc_md60"></a>
Setting the Cross Compile Build as Default</h2>
<p>As we saw above, cross compile builds can be done explicitly by setting the toolchain. However, some users may wish to make this the default, and not need to specify it. This can be done by adding the following line to the deployment <em>CMakeLists.txt</em> file at <code>GpsApp/CMakeList.txt</code>. This is typically done in the first few lines after the <code>project()</code> call.</p>
<div class="fragment"><div class="line">set(FPRIME_DEFAULT_TOOLCHAIN_NAME &quot;raspberrypi&quot;  CACHE STRING &quot;Default toolchain, used in generation&quot; FORCE)</div>
</div><!-- fragment --><p>Now that this is done, we need to purge the old build files in order to ensure that we start again clean. This can be done with the following commands. Notice we are purging all previous build directories we made.</p>
<div class="fragment"><div class="line">fprime-util purge</div>
<div class="line">fprime-util purge raspberrypi</div>
</div><!-- fragment --><p>Now the "raspberrypi" build can be created with a call to <code>fprime-util generate</code> and the original native build can be made by explicitly setting the native toolchain: <code>fprime-util generate native</code>.</p>
<div class="fragment"><div class="line"># Raspberry PI by defaule</div>
<div class="line">fprime-util generate</div>
<div class="line">fprime-util install</div>
<div class="line"> </div>
<div class="line"># Native builds now explicit</div>
<div class="line">fprime-util generate native</div>
<div class="line">fprime-util install native</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md61"></a>
Conclusion</h1>
<p>The GPS tutorial has shown us how to do cross compiling, and running on an embedded Linux system. We have seen how to add components, and wire them to existing drivers. We've seen how to run the ground system, and collect data!</p>
<p>The user is now directed back to the ../README.md "Tutorials" for future reading. More work with the Raspberry PI can be found here: ../../../RPI/README.md "RPI README.md". </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="a_fp_config_8hpp_html_afea3a9ff2b434835add02a2188a3f358"><div class="ttname"><a href="fp_config_8hpp.html#afea3a9ff2b434835add02a2188a3f358">FW_OBJECT_NAMES</a></div><div class="ttdeci">#define FW_OBJECT_NAMES</div><div class="ttdoc">Indicates whether or not object names are stored (more memory, can be used for tracking objects)</div><div class="ttdef"><b>Definition:</b> <a href="fp_config_8hpp_source.html#l00095">FpConfig.hpp:95</a></div></div>
<div class="ttc" id="aclass_fw_1_1_buffer_html"><div class="ttname"><a href="class_fw_1_1_buffer.html">Fw::Buffer</a></div><div class="ttdef"><b>Definition:</b> <a href="buffer_8hpp_source.html#l00043">Buffer.hpp:43</a></div></div>
<div class="ttc" id="asha_8h_html_ae5a6272795b1b8e0045aa7a4319dceb8"><div class="ttname"><a href="sha_8h.html#ae5a6272795b1b8e0045aa7a4319dceb8">U64</a></div><div class="ttdeci">#define U64(C)</div><div class="ttdef"><b>Definition:</b> <a href="sha_8h_source.html#l00176">sha.h:176</a></div></div>
<div class="ttc" id="a_basic_types_8hpp_html_a5a6a98ce49e7a4580aad271214c422bc"><div class="ttname"><a href="basic_types_8hpp.html#a5a6a98ce49e7a4580aad271214c422bc">BYTE</a></div><div class="ttdeci">U8 BYTE</div><div class="ttdoc">byte type</div><div class="ttdef"><b>Definition:</b> <a href="basic_types_8hpp_source.html#l00077">BasicTypes.hpp:77</a></div></div>
<div class="ttc" id="a_fp_config_8hpp_html_a32d34ba1548079db6e25c3d0b1b386f0"><div class="ttname"><a href="fp_config_8hpp.html#a32d34ba1548079db6e25c3d0b1b386f0">FwOpcodeType</a></div><div class="ttdeci">#define FwOpcodeType</div><div class="ttdoc">Type representation for a command opcode.</div><div class="ttdef"><b>Definition:</b> <a href="fp_config_8hpp_source.html#l00062">FpConfig.hpp:62</a></div></div>
<div class="ttc" id="aclass_fw_1_1_logger_html_a0a68fd1aef48f608252dd3e84013035a"><div class="ttname"><a href="class_fw_1_1_logger.html#a0a68fd1aef48f608252dd3e84013035a">Fw::Logger::logMsg</a></div><div class="ttdeci">static void logMsg(const char *fmt, POINTER_CAST a0=0, POINTER_CAST a1=0, POINTER_CAST a2=0, POINTER_CAST a3=0, POINTER_CAST a4=0, POINTER_CAST a5=0, POINTER_CAST a6=0, POINTER_CAST a7=0, POINTER_CAST a8=0, POINTER_CAST a9=0)</div><div class="ttdef"><b>Definition:</b> <a href="logger_8cpp_source.html#l00018">Logger.cpp:18</a></div></div>
<div class="ttc" id="a_basic_types_8hpp_html"><div class="ttname"><a href="basic_types_8hpp.html">BasicTypes.hpp</a></div><div class="ttdoc">Declares ISF basic types.</div></div>
<div class="ttc" id="a_basic_types_8hpp_html_ae2c29dc7dc30247eb4144d3d058d1852"><div class="ttname"><a href="basic_types_8hpp.html#ae2c29dc7dc30247eb4144d3d058d1852">NATIVE_INT_TYPE</a></div><div class="ttdeci">int NATIVE_INT_TYPE</div><div class="ttdoc">native integer type declaration</div><div class="ttdef"><b>Definition:</b> <a href="basic_types_8hpp_source.html#l00029">BasicTypes.hpp:29</a></div></div>
<div class="ttc" id="a_logger_8hpp_html"><div class="ttname"><a href="logger_8hpp.html">Logger.hpp</a></div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
