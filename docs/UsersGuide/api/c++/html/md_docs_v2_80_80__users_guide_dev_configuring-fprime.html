<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>F´ Flight Software - C/C++ Documentation: Configuring F´</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">F´ Flight Software - C/C++ Documentation
   &#160;<span id="projectnumber">NASA-v1.6.0</span>
   </div>
   <div id="projectbrief">A framework for building embedded system applications to NASA flight quality standards.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_docs_v2_80_80__users_guide_dev_configuring-fprime.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Configuring F´ </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This guide is a first attempt to describe the various configuration settings in F´. Most users can operate with the default settings, but as the system design is finalized, some of these options may need to be changed such that the system is most efficient.</p>
<p>This guide includes:</p><ul>
<li><a href="#how-to-configure-f">How to Configure F´</a></li>
<li><a href="#acconstantsini">AcConstants.ini</a></li>
<li><a href="#fpconfighpp">FpConfig.hpp</a><ul>
<li><a href="#type-settings">Type Settings</a></li>
<li><a href="#object-settings">Object Settings</a></li>
<li><a href="#asserts">Asserts</a></li>
<li><a href="#port-tracing">Port Tracing</a></li>
<li><a href="#port-serialization">Port Serialization</a></li>
<li><a href="#serializable-type-id">Serialization Type ID</a></li>
<li><a href="#buffer-sizes">Buffer Sizes</a></li>
<li><a href="#text-logging">Text Logging</a></li>
<li><a href="#misc-configuration-settings">Misc Configuration Settings</a></li>
</ul>
</li>
<li><a href="#component-configuration">Component Configuration</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md895"></a>
How To Configure F´</h1>
<p>All configurable files (top-level and component-specific) for F´ are available in the top-level <code>config</code> directory. By default, all deployments use the F´ provided default configuration options, but as of F´ version 1.5, deployments can provide their own <code>AcConstants.ini</code> and configuration <code>*.hpp</code> files by using the <code>ac_constants</code> and <code>config_directory</code> options in the deployment's <code>settings.ini</code> file. See the ../user/settings.md "settings.ini guide" for more details.</p>
<p>A deployment can clone <code>AcConstants.ini</code> or the whole set of <code>*.hpp</code> files or both. The deployment must take ownership of all <code>*.hpp</code> due to C++ compiler constraints.</p>
<p>AcConstants.ini follows <a href="https://docs.python.org/3/library/configparser.html#supported-ini-file-structure">python's INI</a> format and the <code><a class="el" href="fp_config_8hpp.html" title="ISF configuration file.">FpConfig.hpp</a></code> file is a C++ header allowing the user to define global settings. Where components allow specific configuration, a <code>&lt;component&gt;Cfg.hpp</code> is available to be modified as well.</p>
<h1><a class="anchor" id="autotoc_md896"></a>
AcConstants.ini</h1>
<p>AcConstants.ini is used to set the constants for the autocoded components provided by the framework. This allows projects to appropriately size the number of ports provided by many of the command and data handling components defined in the <code><a class="el" href="namespace_svc.html">Svc</a></code> package. <b>Note:</b> internal configurations like table sizes are set in the component specific header as these settings aren't autocoded. See: <a href="#component-configuration">Component Configuration</a></p>
<p>These settings may need to be increased for large projects with many components, or minimized for projects with a small number of components.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Setting </th><th class="markdownTableHeadNone">Description </th><th class="markdownTableHeadNone">Default </th><th class="markdownTableHeadNone">Valid Values  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ActiveRateGroupOutputPorts </td><td class="markdownTableBodyNone">Number of outputs from active rate group. Limits number of components attached to a single rate group </td><td class="markdownTableBodyNone">10 </td><td class="markdownTableBodyNone">Positive integer  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">CmdDispatcherComponentCommandPorts </td><td class="markdownTableBodyNone">Number of command and command registration ports. Limits number of components handling commands </td><td class="markdownTableBodyNone">30 </td><td class="markdownTableBodyNone">Positive integer  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CmdDispatcherSequencePorts </td><td class="markdownTableBodyNone">Number of incoming ports to command dispatcher, e.g. uplink and command sequencer </td><td class="markdownTableBodyNone">5 </td><td class="markdownTableBodyNone">Positive integer  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">RateGroupDriverRateGroupPorts </td><td class="markdownTableBodyNone">Number of rate group driver output ports. Limits total number of different rate groups </td><td class="markdownTableBodyNone">3 </td><td class="markdownTableBodyNone">Positive integer  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">HealthPingPorts </td><td class="markdownTableBodyNone">Number of health ping output ports. Limits number of components attached to health component </td><td class="markdownTableBodyNone">25 </td><td class="markdownTableBodyNone">Positive integer  </td></tr>
</table>
<p>An example INI setting would look like:</p>
<div class="fragment"><div class="line">setting = 123; Comment</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md897"></a>
FpConfig.hpp</h1>
<p>Some configurations may be changed during compilation time. The F′ framework has a number of optional features that can be enabled or disabled by editing the <code><a class="el" href="fp_config_8hpp.html" title="ISF configuration file.">config/FpConfig.hpp</a></code> file. These changes affect of the whole of the F´ deployment. Users can change or override defined <em>C</em> macro values that activate or disable code by using compiler flags for different deployment settings. During flight software (FSW) execution, disabling unnecessary features saves memory and CPU cycles.</p>
<p>All of these settings should be set in <code><a class="el" href="fp_config_8hpp.html" title="ISF configuration file.">FpConfig.hpp</a></code> and for most projects, this whole file will be cloned and owned for their specific settings. These settings, typically the user will define the setting to be 0 for off and 1 for on.</p>
<p>e.g. </p><div class="fragment"><div class="line"><span class="preprocessor">#define FW_SOME_SETTING 1</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md898"></a>
Type Settings</h2>
<p>Many architectures support different sizes of types. In addition, projects may wish to change the size of the various custom types specified in the framework. This section will describe these settings.</p>
<h3><a class="anchor" id="autotoc_md899"></a>
Architecture Supported Primitive Types</h3>
<p>The architecture is designed to be portable to different processor architectures. Some architectures such as small microcontrollers do not support the full range of types. The architecture supports a non-sized integer type named NATIVE_INT_TYPE. The NATIVE_INT_TYPE is recommended for code (e.g., loop variables) where a particular size is not needed in order to make it more portable. An additional type NATIVE_UINT_TYPE is available for unsigned variables. These types are defined in <code><a class="el" href="basic_types_8hpp.html" title="Declares ISF basic types.">Fw/Types/BasicTypes.hpp</a></code> and use compiler macros for sizing. See: ./../user/enum-arr-ser.md "Primitive Types"</p>
<p>In addition to these types, F´ specifies types of a given size and allows for configuration values to turn the larger types on/off such that smaller architectures can disable them. These settings are described below.</p>
<p><b>Table 32.</b> Macros for supported types.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Macro </th><th class="markdownTableHeadNone">Definition </th><th class="markdownTableHeadNone">Default </th><th class="markdownTableHeadNone">Valid Values  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">FW_HAS_64_BIT </td><td class="markdownTableBodyNone">The architecture supports 64-bit integers. </td><td class="markdownTableBodyNone">1 (on) </td><td class="markdownTableBodyNone">0 (off) 1 (on)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">FW_HAS_32_BIT </td><td class="markdownTableBodyNone">The architecture supports 32-bit integers. </td><td class="markdownTableBodyNone">1 (on) </td><td class="markdownTableBodyNone">0 (off) 1 (on)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">FW_HAS_16_BIT </td><td class="markdownTableBodyNone">The architecture supports 16-bit integers. </td><td class="markdownTableBodyNone">1 (on) </td><td class="markdownTableBodyNone">0 (off) 1 (on)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">FW_HAS_F64 </td><td class="markdownTableBodyNone">The architecture supports 64-bit double-precision floating point values. </td><td class="markdownTableBodyNone">1 (on) </td><td class="markdownTableBodyNone">0 (off) 1 (on)  </td></tr>
</table>
<p>Example: </p><div class="fragment"><div class="line">// Turn of 64-bit integers (double)</div>
<div class="line">#define FW_HAS_F64 0</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md900"></a>
Configured Type Definitions</h3>
<p><b>WARNING:</b> to run the system with the standard F´ GDS, these changes need to be made in the python GDS support code as well as here. This is non-trivial and will be fixed in future releases. Unless the project intended to modify the GDS code, or use an alternate GDS for all functions, these settings should be left as their defaults.</p>
<p>The value which represents a serialized boolean can be set using these macros. This only affects what value is written when the boolean is serialized</p>
<p><b>Table 33:</b> Macros for boolean serialization</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Macro </th><th class="markdownTableHeadNone">Definition </th><th class="markdownTableHeadNone">Default </th><th class="markdownTableHeadNone">Valid Values  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">FW_SERIALIZE_TRUE_VALUE </td><td class="markdownTableBodyNone">True value when serialized </td><td class="markdownTableBodyNone">0xFF </td><td class="markdownTableBodyNone">0 to 0xFF  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">FW_SERIALIZE_FALSE_VALUE </td><td class="markdownTableBodyNone">False value when serialized </td><td class="markdownTableBodyNone">0x00 </td><td class="markdownTableBodyNone">0 to 0xFF  </td></tr>
</table>
<p>Special named types used by F´ are mapped to some form of a primitive type integer type. This is done for ease of reading F´ code and is a standard practice in C/C++. The framework allows projects to change the type they used for these types to optimize transmitted bytes. Again, any changes must match the GDS in order to decode the values correctly and thus changing these values should be done carefully.</p>
<p><b>Table 34:</b> Macros for custom types</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Macro </th><th class="markdownTableHeadNone">Definition </th><th class="markdownTableHeadNone">Default </th><th class="markdownTableHeadNone">Valid Values  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">FwPacketDescriptorType </td><td class="markdownTableBodyNone">Type storing F´ packet type descriptor </td><td class="markdownTableBodyNone">U32 </td><td class="markdownTableBodyNone">U8, U16, U32, U64  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">FwOpcodeType </td><td class="markdownTableBodyNone">Type storing F´ opcodes </td><td class="markdownTableBodyNone">U32 </td><td class="markdownTableBodyNone">U8, U16, U32, U64  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">FwChanIdType </td><td class="markdownTableBodyNone">Type storing F´ channel ids </td><td class="markdownTableBodyNone">U32 </td><td class="markdownTableBodyNone">U8, U16, U32, U64  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">FwEventIdType </td><td class="markdownTableBodyNone">Type storing F´ event ids </td><td class="markdownTableBodyNone">U32 </td><td class="markdownTableBodyNone">U8, U16, U32, U64  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">FwPrmIdType </td><td class="markdownTableBodyNone">Type storing F´ parameter ids </td><td class="markdownTableBodyNone">U32 </td><td class="markdownTableBodyNone">U8, U16, U32, U64  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">FwBuffSizeType </td><td class="markdownTableBodyNone">Type storing the size of an F´ buffer </td><td class="markdownTableBodyNone">U16 </td><td class="markdownTableBodyNone">U8, U16, U32, U64  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">FwEnumStoreType </td><td class="markdownTableBodyNone">Type storing F´ enum values </td><td class="markdownTableBodyNone">I32 </td><td class="markdownTableBodyNone">I8, I16, I32, I64  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">FwTimeBaseStoreType </td><td class="markdownTableBodyNone">Type storing F´ timebase enum </td><td class="markdownTableBodyNone">U16 </td><td class="markdownTableBodyNone">U8, U16, U32, U64  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">FwTimeContextStoreType </td><td class="markdownTableBodyNone">Type storing F´ time context </td><td class="markdownTableBodyNone">U8 </td><td class="markdownTableBodyNone">U8, U16, U32, U64  </td></tr>
</table>
<p><b>Note:</b> for a further understanding of timebase and time context, see the next section.</p>
<h3><a class="anchor" id="autotoc_md901"></a>
Time Base and Time Context</h3>
<p>The F′ time tags have a field that specifies the time base of the time tag. A time base is defined as a clock in the system correlated with a known epoch. It is often the case that when a system is being initialized, it does not always have access to a clock correlated to external operations. It can transition through several time bases (processor, radio, Earth) on the way to becoming fully operational. The TimeBase type defines the set of clocks in the system tha can produce a time tag. It lets users of the system see which clock was used when time tagging telemetry.</p>
<p>Time contexts are another value associated with the time.</p>
<p><b>WARNING:</b> changes to this value must be done in tandem with the F´ GDS for F´ GDS features to work. Thus most projects don't modify these settings just like the types defined above.</p>
<div class="fragment"><div class="line">enum TimeBase {</div>
<div class="line">    TB_NONE, //!&lt; No time base has been established</div>
<div class="line">    TB_PROC_TIME, //!&lt; Indicates time is processor cycle time. Not tied to external time</div>
<div class="line">    TB_WORKSTATION_TIME, //!&lt; Time as reported on workstation where software is running. For testing.</div>
<div class="line">    TB_DONT_CARE = 0xFFFF //!&lt; Don&#39;t care value for sequences. If FwTimeBaseStoreType is changed, value should be changed</div>
<div class="line">};</div>
</div><!-- fragment --><p>Time base and time context usage may be turned on and off using the macros shown below:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Macro </th><th class="markdownTableHeadNone">Definition </th><th class="markdownTableHeadNone">Default </th><th class="markdownTableHeadNone">Valid Values  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">FW_USE_TIME_BASE </td><td class="markdownTableBodyNone">Enables the time base Fw::time field </td><td class="markdownTableBodyNone">1 (on) </td><td class="markdownTableBodyNone">0 (off) 1 (on)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">FW_USE_TIME_CONTEXT </td><td class="markdownTableBodyNone">Enables the time context Fw::time field </td><td class="markdownTableBodyNone">1 (on) </td><td class="markdownTableBodyNone">0 (off) 1 (on)  </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md902"></a>
Object Settings</h2>
<p>The architecture allows for various settings to control, monitor, and trace objects in the system. These settings typically result in a larger binary size, but make the framework and system easier to debug. This section includes a discussion of OS objects like Tasks and Queues as well.</p>
<h3><a class="anchor" id="autotoc_md903"></a>
Object Naming</h3>
<p>The architecture can store names for each object created. This is useful when using object registries or tracing to see what objects exist and how they interact. The object naming does increase the per-object storage and code size, so in a resource-constrained environment, disabling this feature might be desirable. This macro should be used in developer implementation classes to call the correct constructor in the code-generated base classes. Table 35 provides the macros related to this feature.</p>
<p>The <code><a class="el" href="class_os_1_1_queue.html">Os::Queue</a></code> class stores a queue name as private data. Table 35 provides the macro for this feature. The <code><a class="el" href="class_os_1_1_task.html" title="forward declaration">Os::Task</a></code> class stores a task name as private data. Table 35 provides the macro for this feature as well.</p>
<p><b>Table 35.</b> Macros for object naming, queue naming, and task naming</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Macro </th><th class="markdownTableHeadNone">Definition </th><th class="markdownTableHeadNone">Default </th><th class="markdownTableHeadNone">Valid Values  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">FW_OBJECT_NAMES </td><td class="markdownTableBodyNone">Enables storage and retrieval of the name </td><td class="markdownTableBodyNone">1 (on) </td><td class="markdownTableBodyNone">0 (off) 1 (on)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">FW_OBJ_NAME_MAX_SIZE </td><td class="markdownTableBodyNone">Size of the buffer storing the object name </td><td class="markdownTableBodyNone">80 </td><td class="markdownTableBodyNone">Positive integer  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">FW_QUEUE_NAME_MAX_SIZE </td><td class="markdownTableBodyNone">Size of the buffer storing the queue names </td><td class="markdownTableBodyNone">80 </td><td class="markdownTableBodyNone">Positive integer  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">FW_TASK_NAME_MAX_SIZE </td><td class="markdownTableBodyNone">Size of the buffer storing task names </td><td class="markdownTableBodyNone">80 </td><td class="markdownTableBodyNone">Positive integer  </td></tr>
</table>
<p><b>Note:</b> The macro <code>FW_OPTIONAL_NAME("string")</code> can be used to conditionally return the given string or an empty string depending on whether <code>FW_OBJECT_NAMES</code> is on. This can be used to strip out component names from code when building without <code>FW_OBJECT_NAMES</code>.</p>
<p><b>Note:</b> If the size of the string passed to the code-generated component base classes is larger than this size, the string will be truncated. FW_OBJECT_NAMES must be turned on for FW_OBJ_NAME_MAX_SIZ to have any effect.</p>
<p><b>Note:</b> FW_QUEUE_NAME_MAX_SIZE and FW_TASK_NAME_MAX_SIZE are only used if FW_OBJECT_NAMES is <b>turned off</b>. Otherwise the supplied object name is used.</p>
<h3><a class="anchor" id="autotoc_md904"></a>
Object to String</h3>
<p>The framework port and object classes have an optional toString() method. This method by default returns the instance name of the object, but toString() is defined as a virtual method so a developer class can override this and provide custom information. Table 35 provides the macros to configure this feature.</p>
<p><b>Note:</b> for these settings to work FW_OBJECT_NAMES must be turned on.</p>
<p><b>Table 36.</b> Macros for object to string.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Macro </th><th class="markdownTableHeadNone">Definition </th><th class="markdownTableHeadNone">Default </th><th class="markdownTableHeadNone">Valid Values  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">FW_OBJECT_TO_STRING </td><td class="markdownTableBodyNone">Enables the toString() method </td><td class="markdownTableBodyNone">1 (on) </td><td class="markdownTableBodyNone">0 (off) 1 (on)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">FW_OBJ_TO_STRING_BUFFER_SIZE </td><td class="markdownTableBodyNone">Defines buffer size used to store toString() results </td><td class="markdownTableBodyNone">255 </td><td class="markdownTableBodyNone">Positive integer  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">FW_SERIALIZABLE_TO_STRING </td><td class="markdownTableBodyNone">Defines a toString() method for code-generated serializable </td><td class="markdownTableBodyNone">1 (on) </td><td class="markdownTableBodyNone">0 (off) 1 (on)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">FW_SERIALIZABLE_TO_STRING_BUFFER_SIZE </td><td class="markdownTableBodyNone">Defines buffer size of toString() result for serializables </td><td class="markdownTableBodyNone">255 </td><td class="markdownTableBodyNone">Positive integer  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">FW_ARRAY_TO_STRING </td><td class="markdownTableBodyNone">Defines a toString() method for code-generated arrays </td><td class="markdownTableBodyNone">1 (on) </td><td class="markdownTableBodyNone">0 (off) 1 (on)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">FW_ARRAY_TO_STRING_BUFFER_SIZE </td><td class="markdownTableBodyNone">Defines buffer size of toString() result for arrays </td><td class="markdownTableBodyNone">256 </td><td class="markdownTableBodyNone">Positive integer  </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md905"></a>
Object Registry</h3>
<p>An object registry is a class that holds a list of framework component and port objects. The registry can be used to list all the objects, or call common functions on all objects. A base class for the object registry is defined in <code><a class="el" href="obj_base_8hpp.html" title="Declarations for Fw::ObjBase and Fw::ObjRegistry.">Fw/Obj/ObjBase.hpp</a></code>, and a simple implementation can be found in <code><a class="el" href="simple_obj_registry_8hpp.html" title="Class declaration for a simple object registry.">Fw/Obj/SimpleObjRegistry.hpp</a></code>. Table 37 provides the macros to configure this feature. Message queues allow for their own registration such that the project may track them as well.</p>
<p><b>Table 37.</b> Macros for object registry.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Macro </th><th class="markdownTableHeadNone">Definition </th><th class="markdownTableHeadNone">Default </th><th class="markdownTableHeadNone">Valid Values  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">FW_OBJECT_REGISTRATION </td><td class="markdownTableBodyNone">Enables object registries. </td><td class="markdownTableBodyNone">1 (on) </td><td class="markdownTableBodyNone">0 (off) 1 (on)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">FW_OBJ_SIMPLE_REG_ENTRIES </td><td class="markdownTableBodyNone">The size of the array in the simple object registry used to store objects. </td><td class="markdownTableBodyNone">500 </td><td class="markdownTableBodyNone">Positive integer  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">FW_OBJ_SIMPLE_REG_BUFF_SIZE </td><td class="markdownTableBodyNone">The size of the buffer used to store object names in the simple registry. </td><td class="markdownTableBodyNone">255 </td><td class="markdownTableBodyNone">Positive integer  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">FW_QUEUE_REGISTRATION </td><td class="markdownTableBodyNone">Enables queue registries. </td><td class="markdownTableBodyNone">1 (on) </td><td class="markdownTableBodyNone">0 (off) 1 (on)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">FW_QUEUE_SIMPLE_QUEUE_ENTRIES </td><td class="markdownTableBodyNone">The size of the array in the simple object registry used to store queues. </td><td class="markdownTableBodyNone">100 </td><td class="markdownTableBodyNone">Positive integer  </td></tr>
</table>
<p><b>Note:</b> FW_OBJECT_REGISTRATION must be turned on for FW_OBJ_SIMPLE_REG_ENTRIES and FW_OBJ_SIMPLE_REG_BUFF_SIZE to have any effect.</p>
<p><b>Note:</b> See table 35 for configuring queue name sizes.</p>
<h2><a class="anchor" id="autotoc_md906"></a>
Asserts</h2>
<p>The assert feature is described in <a class="el" href="v2_80_80_2_users_guide_2dev_2assert_8md.html">F´ Asserts</a>. This configuration allows a project to turn asserts off, use hash IDs for the assert message, or use full filenames for the assert message. Table 38 provides ways that asserts can be configured.</p>
<p><b>Table 38.</b> Macros for assert.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Macro </th><th class="markdownTableHeadNone">Definition </th><th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone">Default  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">FW_ASSERT_LEVEL </td><td class="markdownTableBodyNone">Sets the assert report level to: </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">FW_FILENAME_ASSERT  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"><b>Value</b> </td><td class="markdownTableBodyNone"><b>Definition</b> </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">FW_NO_ASSERT </td><td class="markdownTableBodyNone">Asserts turned off, removing all assert code. </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">FW_FILEID_ASSERT </td><td class="markdownTableBodyNone">Asserts turned on, hash value used in place of <b>FILE</b> on message </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">FW_FILENAME_ASSERT </td><td class="markdownTableBodyNone">Asserts turned on, <b>FILE</b> macro is used in the assert message </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">FW_ASSERT_TEXT_SIZE </td><td class="markdownTableBodyNone">The buffer size used to store the assert message </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">120  </td></tr>
</table>
<p>Setting assert level FW_FILEID_ASSERT saves a lot of code space since no file name is stored. The make system supplies this to the compiler by hashing the file name. The original filename can be recovered by running <code>fprime-util hash-to-file &lt;hash&gt;</code>.</p>
<p>Setting assert level to FW_ASSERT_TEXT_SIZE can ease debugging asserts, but typically FW_ASSERT_TEXT_SIZE must be increased as most file name paths are longer than 120.</p>
<h2><a class="anchor" id="autotoc_md907"></a>
Port Tracing</h2>
<p>When components are interconnected, it is often useful to trace the set of invocations through components and ports. The port base class has a <code>trace()</code> call that is invoked by the derived port classes whenever the port is invoked. The <code>trace()</code> calls <code><a class="el" href="class_os_1_1_log.html#a6e213c4af5a66a33ffb719465826f212">Os::Log::log()</a></code> with the name of the port once the port base class method <code>setTrace()</code> has been called. Individual ports can be have tracing turned on and off by calling the <code>overrideTrace()</code> method on the port instance. Table 39 provides the macro to configure this feature.</p>
<p><b>Table 39.</b> Macro for port tracing.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Macro </th><th class="markdownTableHeadNone">Definition </th><th class="markdownTableHeadNone">Default </th><th class="markdownTableHeadNone">Valid Values  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">FW_PORT_TRACING </td><td class="markdownTableBodyNone">Enables port tracing. </td><td class="markdownTableBodyNone">1 (on) </td><td class="markdownTableBodyNone">0 (off) 1 (on)  </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md908"></a>
Port Serialization</h2>
<p>As discussed in the user guide, a port type (Input/OutputSerializePort) exists that has no interface type, but instead receives (or sends) a serialized form of the port invocation for the attached port. The primary pattern for this is to invoke components on remote nodes. The code generator generates code in each port that will serialize or deserialize the invocation if it detects that it is connected to a serializing port. If development is for a single node, this feature can be disabled to reduce the code size. Table 40 provides the macro to configure this feature.</p>
<p><b>Table 40.</b> Macro for port serialization.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Macro </th><th class="markdownTableHeadNone">Definition </th><th class="markdownTableHeadNone">Default </th><th class="markdownTableHeadNone">Valid Values  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">FW_PORT_SERIALIZATION </td><td class="markdownTableBodyNone">Enables port serialization. </td><td class="markdownTableBodyNone">1 (on) </td><td class="markdownTableBodyNone">0 (off) 1 (on)  </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md909"></a>
Serializable Type ID</h2>
<p>As described ../user/enum-arr-ser.md "in serializable types", serializable types can be defined for use in the code. When objects of those types are serialized, an integer representing the type ID can be serialized along with the object data. This allows the type to be determined later if only the serialized form is available. Turning off this feature will lower the amount of data moved around for a given object when it is serialized. Table 41 provides the macros to configure this feature.</p>
<p><b>Table 41.</b> Macros for serializable type ID.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Macro </th><th class="markdownTableHeadNone">Definition </th><th class="markdownTableHeadNone">Default </th><th class="markdownTableHeadNone">Valid Values  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">FW_SERIALIZATION_TYPE_ID </td><td class="markdownTableBodyNone">Enables serializing the type ID </td><td class="markdownTableBodyNone">0 (off) </td><td class="markdownTableBodyNone">0 (off) 1 (on)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">FW_SERIALIZATION_TYPE_ID_BYTES </td><td class="markdownTableBodyNone">Defines size of serialization ID </td><td class="markdownTableBodyNone">4 </td><td class="markdownTableBodyNone">1 - 4  </td></tr>
</table>
<p><b>Note:</b> smaller values for FW_SERIALIZATION_TYPE_ID_BYTES means that less data storage is needed, but also limits the number of types that can be defined. FW_SERIALIZATION_TYPE_ID is required to have type IDs in the buffer and thus to introspect what type is contained in the buffer.</p>
<h2><a class="anchor" id="autotoc_md910"></a>
Buffer Sizes</h2>
<p>Many of the built in F´ data types define buffer sizes that allow them to be passed as a com buffer type, sent out through the ground interface, serialized and more. This section will discuss the com buffer configuration, command, channel, event, parameter and other buffer size arguments.</p>
<p>The com buffer must be able to store all the other types such that they can all be passed as generic communication. Thus FW_COM_BUFFER_MAX_SIZE must be large enough to hold each buffer size <b>and</b> the header data for each type. Thus these settings are typically derived and this is done by default. <b>WARNING:</b> only modify the comm buffer size to ensure that there will be no faults in the system.</p>
<p>In all cases, these definitions are global for each types in the system. Thus the buffer <b>must</b> be large enough to hold the data for the largest of a given type in the system. An assert will result if the buffer is set too-small. i.e. the FW_CMD_ARG_BUFFER_MAX_SIZE cannot be smaller than the serialized size of the command with the largest arguments.</p>
<p>These types also provide optional string sizes for their constituent pieces. However, the MAX_STRING_SIZE settings must <b>always</b> be smaller than the BUFFER_MAX_SIZE. i.e. the command string max size cannot be larger than the command buffer max size, as the string is serialized into the buffer.</p>
<p>Commands serialize argument values into these buffers. Events (aka log events) also serialize just the arguments. Channelized telemetry and parameters serialize the values. Other information like event strings is not serialized but rather reconstructed when needed from the dictionary. This is all placed in a comm buffer.</p>
<p>Table 42 provides the macros to configure these features.</p>
<p><b>Table 42.</b> Macros for buffers.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Macro </th><th class="markdownTableHeadNone">Definition </th><th class="markdownTableHeadNone">Default </th><th class="markdownTableHeadNone">Valid Values  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">FW_COM_BUFFER_MAX_SIZE </td><td class="markdownTableBodyNone">Defines the size of a com buffer </td><td class="markdownTableBodyNone">128 </td><td class="markdownTableBodyNone">Positive integer  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">FW_CMD_ARG_BUFFER_MAX_SIZE </td><td class="markdownTableBodyNone">Defines the size of command argument buffers </td><td class="markdownTableBodyNone">Derived </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">FW_CMD_STRING_MAX_SIZE </td><td class="markdownTableBodyNone">Defines the maximum size of a command string argument </td><td class="markdownTableBodyNone">40 </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">FW_LOG_BUFFER_MAX_SIZE </td><td class="markdownTableBodyNone">Defines the size of event buffers </td><td class="markdownTableBodyNone">Derived </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">FW_LOG_STRING_MAX_SIZE </td><td class="markdownTableBodyNone">Defines the maximum size of an event string argument </td><td class="markdownTableBodyNone">100 </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">FW_TLM_BUFFER_MAX_SIZE </td><td class="markdownTableBodyNone">Defines the size of telemetry channel buffers </td><td class="markdownTableBodyNone">Derived </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">FW_TLM_STRING_MAX_SIZE </td><td class="markdownTableBodyNone">Defines the maximum size of a channel string value </td><td class="markdownTableBodyNone">40 </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">FW_PRM_BUFFER_MAX_SIZE </td><td class="markdownTableBodyNone">Defines the size of parameter buffers </td><td class="markdownTableBodyNone">Derived </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">FW_PRM_STRING_MAX_SIZE </td><td class="markdownTableBodyNone">Defines the maximum size of a parameter string value </td><td class="markdownTableBodyNone">40 </td><td class="markdownTableBodyNone"></td></tr>
</table>
<p>Other Buffers are defined in the system for specific purposes. These do not need to fit inside a comm buffer, and thus are less restrictive in sizing.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Macro </th><th class="markdownTableHeadNone">Definition </th><th class="markdownTableHeadNone">Default </th><th class="markdownTableHeadNone">Valid Values  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">FW_FILE_BUFFER_MAX_SIZE </td><td class="markdownTableBodyNone">Defines buffer and chunk size for file uplink and downlink </td><td class="markdownTableBodyNone">255 </td><td class="markdownTableBodyNone">Positive integer  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">FW_INTERNAL_INTERFACE_STRING_MAX_SIZE </td><td class="markdownTableBodyNone">Maximum size for interface string </td><td class="markdownTableBodyNone">40 </td><td class="markdownTableBodyNone">Positive integer  </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md911"></a>
Text Logging</h2>
<p>Event functions that are called are turned into two output port calls. One is a binary port that is used to store the event to be transported to ground software or a testing interface external to the software. The component also takes the format string specified in the XML and populates it with the event arguments, and calls an output port with a readable text version of the event. This is meant to be used for a console interface so the user can see, in text form, the same events being stored for transmission. A component with the text logging input port can be used to display the text. A very simple implementation of this can be seen in <code>Svc/PassiveConsoleTextLogger</code>. In a resource-constrained environment or in a flight implementation where the console is not viewable, the text formatting and extra code can consume an undesirable number of processor cycles. For this reason, the text logging can be turned off via a macro. This compiles out the code and format strings for text logging. Table 46 provides the macros to configure text logging.</p>
<p><b>Table 46.</b> Macros for text logging.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Macro </th><th class="markdownTableHeadNone">Definition </th><th class="markdownTableHeadNone">Default </th><th class="markdownTableHeadNone">Valid Values  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">FW_ENABLE_TEXT_LOGGING </td><td class="markdownTableBodyNone">Enables or disables text logging </td><td class="markdownTableBodyNone">1 (on) </td><td class="markdownTableBodyNone">0 (off) 1 (on)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">FW_LOG_TEXT_BUFFER_SIZE </td><td class="markdownTableBodyNone">Maximum size of the textual representation of the event </td><td class="markdownTableBodyNone">256 </td><td class="markdownTableBodyNone">Positive integer  </td></tr>
</table>
<p><b>Note:</b> the FW_LOG_TEXT_BUFFER_SIZE should be large enough to store the full event including its text format string after being populated with arguments.</p>
<h2><a class="anchor" id="autotoc_md912"></a>
Misc Configuration Settings</h2>
<p>This setting describes some of the other settings available in <code><a class="el" href="fp_config_8hpp.html" title="ISF configuration file.">FpConfig.hpp</a></code> and did not fit in other sections. These are described in tables below. Table 47 describes other user settings. Table 48 describes settings defined by the build system that should never be hand-set.</p>
<p><b>Table 48.</b> Misc macros available to user.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Macro </th><th class="markdownTableHeadNone">Definition </th><th class="markdownTableHeadNone">Default </th><th class="markdownTableHeadNone">Valid Values  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">FW_CMD_CHECK_RESIDUAL </td><td class="markdownTableBodyNone">Enables command serialization extra bytes check </td><td class="markdownTableBodyNone">1 (on) </td><td class="markdownTableBodyNone">0 (off) 1 (on)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">FW_AMPCS_COMPATIBLE </td><td class="markdownTableBodyNone">Adds argument sizes to event argument serialization </td><td class="markdownTableBodyNone">0 (off) </td><td class="markdownTableBodyNone">0 (off) 1 (on)  </td></tr>
</table>
<p><b>Note:</b> Normally when a command is deserialized, the handler checks to see if there are any leftover bytes in the buffer. If there are, it assumes that the command was corrupted somehow since the serialized size should match the serialized size of the argument list. In some cases, command buffers are padded so the data can be larger than the serialized size of the command. Turning FW_CMD_CHECK_RESIDUAL off can disable this check and allow leftover bytes.</p>
<p><b>Note:</b> some ground systems require the size of the event argument to be serialized into the buffer instead of predicting the size using the dictionary. Setting FW_AMPCS_COMPATIBLE will serialize these sizes into the event buffers <b>and</b> break compatibility with the F´ ground system as it does not use this feature.</p>
<p><b>WARNING:</b> the following settings are defined by the build system and are in <code><a class="el" href="fp_config_8hpp.html" title="ISF configuration file.">FpConfig.hpp</a></code> to provide a default off value. These must be set by the build system as the setting works in unison with other modules that the build system includes when enabling these settings.</p>
<p><b>Table 48.</b> Macros for use by build system only</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Macro </th><th class="markdownTableHeadNone">Definition </th><th class="markdownTableHeadNone">Default </th><th class="markdownTableHeadNone">Valid Values  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">FW_BAREMETAL_SCHEDULER </td><td class="markdownTableBodyNone">Enables baremetal scheduler hooks in active components </td><td class="markdownTableBodyNone">0 (off) </td><td class="markdownTableBodyNone">0 (off) 1 (on)  </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md913"></a>
Component Configuration</h1>
<p>Component configurations are also provided as part of the project's config directory. If the directory is not provided, then the default from the framework is used. <b>Remember:</b> if the project overrides any configuration, that new directory must contain all the component headers as well as the <code><a class="el" href="fp_config_8hpp.html" title="ISF configuration file.">FpConfig.hpp</a></code> as C++ prevents including individual headers.</p>
<p>These component headers follow the form <code>&lt;Component&gt;Cfg.hpp</code> and allows a project to set the configuration for each component's C++ implementation. This is typically to set maximum sizes for tables, and other static memory allocations. Some components allow users to turn on and off features. If a component does not have a header, it has no configuration for the user to set.</p>
<p>Users are encouraged to look through the header for the component of interest as they should be self descriptive.</p>
<h1><a class="anchor" id="autotoc_md914"></a>
Conclusion</h1>
<p>The user should now have a very detailed understanding of how to configure F´. Although there are some automatic checks built into F´ to check for some invalid configurations, the user should take care to understand the implication of changes to these settings. The F´ team sincerely hopes this bombardment of information will prove useful. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
